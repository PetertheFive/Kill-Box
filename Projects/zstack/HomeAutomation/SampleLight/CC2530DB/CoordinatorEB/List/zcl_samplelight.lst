###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               26/Jun/2020  13:33:48
# Copyright 2004-2018 IAR Systems AB.
# Evaluation license - IAR Embedded Workbench for 8051, Evaluation edition 10.30
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\Source\zcl_samplelight.c
#    Command line       =  
#        -f C:\Users\Peter.Wu\AppData\Local\Temp\EWFDBC.tmp ("C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\Source\zcl_samplelight.c"
#        -D ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D
#        LCD_SUPPORTED -lC "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\CoordinatorEB\List"
#        -lA "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\CoordinatorEB\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\CoordinatorEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000)
#        -f "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\" -I
#        "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\Source\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\Source\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\CoordinatorEB\List\zcl_samplelight.lst
#    Object file        =  
#        C:\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\CoordinatorEB\Obj\zcl_samplelight.r51
#
###############################################################################

C:\Z-Stack Home 1.2.2a.44539\Projects\zstack\HomeAutomation\SampleLight\Source\zcl_samplelight.c
      1          /**************************************************************************************************
      2            Filename:       zcl_sampleLight.c
      3            Revised:        $Date: 2014-10-24 16:04:46 -0700 (Fri, 24 Oct 2014) $
      4            Revision:       $Revision: 40796 $
      5          
      6          
      7            Description:    Zigbee Cluster Library - sample device application.
      8          
      9          
     10            Copyright 2006-2014 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License").  You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product.  Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42            This application implements a ZigBee HA 1.2 Light. It can be configured as an
     43            On/Off light, or as a dimmable light. The following flags must be defined in
     44            the compiler's pre-defined symbols.
     45          
     46            ZCL_ON_OFF
     47            ZCL_LEVEL_CTRL    (only if dimming functionality desired)
     48            HOLD_AUTO_START
     49            ZCL_EZMODE
     50          
     51            This device supports all mandatory and optional commands/attributes for the
     52            OnOff (0x0006) and LevelControl (0x0008) clusters.
     53          
     54            SCREEN MODES
     55            ----------------------------------------
     56            Main:
     57              - SW1: Toggle local light
     58              - SW2: Invoke EZMode
     59              - SW4: Enable/Disable local permit join
     60              - SW5: Go to Help screen
     61            ----------------------------------------
     62          *********************************************************************/
     63          
     64          /*********************************************************************
     65           * INCLUDES
     66           */
     67          #include "ZComDef.h"
     68          #include "OSAL.h"
     69          #include "AF.h"
     70          #include "ZDApp.h"
     71          #include "ZDObject.h"
     72          #include "MT_SYS.h"
     73          
     74          #include "nwk_util.h"
     75          
     76          #include "zcl.h"
     77          #include "zcl_general.h"
     78          #include "zcl_ha.h"
     79          #include "zcl_ezmode.h"
     80          #include "zcl_diagnostic.h"
     81          
     82          #include "MT_UART.h"
     83          #include "MT_APP.h"
     84          #include "MT.h"
     85          #include "zcl_samplelight.h"
     86          
     87          #include "onboard.h"
     88          
     89          /* HAL */
     90          #include "hal_lcd.h"
     91          #include "hal_led.h"
     92          #include "hal_key.h"
     93          
     94          #if ( defined (ZGP_DEVICE_TARGET) || defined (ZGP_DEVICE_TARGETPLUS) \
     95                || defined (ZGP_DEVICE_COMBO) || defined (ZGP_DEVICE_COMBO_MIN) )
     96          #include "zgp_translationtable.h"
     97            #if (SUPPORTED_S_FEATURE(SUPP_ZGP_FEATURE_TRANSLATION_TABLE))
     98              #define ZGP_AUTO_TT
     99            #endif
    100          #endif
    101          
    102          #if (defined HAL_BOARD_ZLIGHT) || (defined HAL_PWM)
    103          #include "math.h"
    104          #include "hal_timer.h"
    105          #endif
    106          
    107          #include "NLMEDE.h"
    108          
    109          /*********************************************************************
    110           * MACROS
    111           */
    112          
    113          /*********************************************************************
    114           * CONSTANTS
    115           */
    116          #if (defined HAL_BOARD_ZLIGHT)
    117          #define LEVEL_MAX                 0xFE
    118          #define LEVEL_MIN                 0x0
    119          #define GAMMA_VALUE               2
    120          #define PWM_FULL_DUTY_CYCLE       1000
    121          #elif (defined HAL_PWM)
    122          #define LEVEL_MAX                 0xFE
    123          #define LEVEL_MIN                 0x0
    124          #define GAMMA_VALUE               2
    125          #define PWM_FULL_DUTY_CYCLE       100
    126          #endif
    127          
    128          /*********************************************************************
    129           * TYPEDEFS
    130           */
    131          
    132          /*********************************************************************
    133           * GLOBAL VARIABLES
    134           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    135          byte zclSampleLight_TaskID;
   \                     zclSampleLight_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    136          uint8 zclSampleLightSeqNum;
   \                     zclSampleLightSeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    137          
    138          
    139          /*********************************************************************
    140           * GLOBAL FUNCTIONS
    141           */
    142          
    143          /*********************************************************************
    144           * LOCAL VARIABLES
    145           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    146          afAddrType_t zclSampleLight_DstAddr;
   \                     zclSampleLight_DstAddr:
   \   000000                DS 12
   \   00000C                REQUIRE __INIT_XDATA_Z
    147          
    148          #ifdef ZCL_EZMODE
    149          static void zclSampleLight_ProcessZDOMsgs( zdoIncomingMsg_t *pMsg );
    150          static void zclSampleLight_EZModeCB( zlcEZMode_State_t state, zclEZMode_CBData_t *pData );
    151          
    152          
    153          // register EZ-Mode with task information (timeout events, callback, etc...)
    154          static const zclEZMode_RegisterData_t zclSampleLight_RegisterEZModeData =
    155          {
    156            &zclSampleLight_TaskID,
    157            SAMPLELIGHT_EZMODE_NEXTSTATE_EVT,
    158            SAMPLELIGHT_EZMODE_TIMEOUT_EVT,
    159            &zclSampleLightSeqNum,
    160            zclSampleLight_EZModeCB
    161          };
    162          
    163          #else

   \                                 In  segment XDATA_I, align 1, keep-with-next
    164          uint16 bindingInClusters[] =
   \                     bindingInClusters:
   \   000000                DS 2
   \   000002                REQUIRE `?<Initializer for bindingInClusters>`
   \   000002                REQUIRE __INIT_XDATA_I
    165          {
    166            ZCL_CLUSTER_ID_GEN_ON_OFF
    167          #ifdef ZCL_LEVEL_CTRL
    168            , ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL
    169          #endif
    170          };
    171          #define ZCLSAMPLELIGHT_BINDINGLIST (sizeof(bindingInClusters) / sizeof(bindingInClusters[0]))
    172          
    173          #endif  // ZCL_EZMODE
    174          
    175          // Test Endpoint to allow SYS_APP_MSGs

   \                                 In  segment XDATA_I, align 1, keep-with-next
    176          static endPointDesc_t sampleLight_TestEp =
   \                     sampleLight_TestEp:
   \   000000                DS 6
   \   000006                REQUIRE `?<Initializer for sampleLight_TestEp>`
   \   000006                REQUIRE __INIT_XDATA_I
    177          {
    178            SAMPLELIGHT_ENDPOINT,
    179            &zclSampleLight_TaskID,
    180            (SimpleDescriptionFormat_t *)NULL,  // No Simple description for this test endpoint
    181            (afNetworkLatencyReq_t)0            // No Network Latency req
    182          };
    183          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    184          uint8 giLightScreenMode = LIGHT_MAINMODE;   // display the main screen mode first
   \                     giLightScreenMode:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    185          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    186          uint8 gPermitDuration = 0;    // permit joining default to disabled
   \                     gPermitDuration:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    187          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    188          devStates_t zclSampleLight_NwkState = DEV_INIT;
   \                     zclSampleLight_NwkState:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for zclSampleLight_NwkState>`
   \   000001                REQUIRE __INIT_XDATA_I
    189          
    190          #if ZCL_LEVEL_CTRL
    191          uint8 zclSampleLight_WithOnOff;       // set to TRUE if state machine should set light on/off
    192          uint8 zclSampleLight_NewLevel;        // new level when done moving
    193          bool  zclSampleLight_NewLevelUp;      // is direction to new level up or down?
    194          int32 zclSampleLight_CurrentLevel32;  // current level, fixed point (e.g. 192.456)
    195          int32 zclSampleLight_Rate32;          // rate in units, fixed point (e.g. 16.123)
    196          uint8 zclSampleLight_LevelLastLevel;  // to save the Current Level before the light was turned OFF
    197          #endif
    198          
    199          /*********************************************************************
    200           * LOCAL FUNCTIONS
    201           */
    202          static void zclSampleLight_HandleKeys( byte shift, byte keys );
    203          static void zclSampleLight_BasicResetCB( void );
    204          static void zclSampleLight_IdentifyCB( zclIdentify_t *pCmd );
    205          static void zclSampleLight_IdentifyQueryRspCB( zclIdentifyQueryRsp_t *pRsp );
    206          static void zclSampleLight_OnOffCB( uint8 cmd );
    207          static void zclSampleLight_ProcessIdentifyTimeChange( void );
    208          #ifdef ZCL_LEVEL_CTRL
    209          static void zclSampleLight_LevelControlMoveToLevelCB( zclLCMoveToLevel_t *pCmd );
    210          static void zclSampleLight_LevelControlMoveCB( zclLCMove_t *pCmd );
    211          static void zclSampleLight_LevelControlStepCB( zclLCStep_t *pCmd );
    212          static void zclSampleLight_LevelControlStopCB( void );
    213          static void zclSampleLight_DefaultMove( void );
    214          static uint32 zclSampleLight_TimeRateHelper( uint8 newLevel );
    215          static uint16 zclSampleLight_GetTime ( uint8 level, uint16 time );
    216          static void zclSampleLight_MoveBasedOnRate( uint8 newLevel, uint32 rate );
    217          static void zclSampleLight_MoveBasedOnTime( uint8 newLevel, uint16 time );
    218          static void zclSampleLight_AdjustLightLevel( void );
    219          #endif
    220          
    221          // app display functions
    222          static void zclSampleLight_LcdDisplayUpdate( void );
    223          #ifdef LCD_SUPPORTED
    224          static void zclSampleLight_LcdDisplayMainMode( void );
    225          static void zclSampleLight_LcdDisplayHelpMode( void );
    226          #endif
    227          static void zclSampleLight_DisplayLight( void );
    228          
    229          #if (defined HAL_BOARD_ZLIGHT) || (defined HAL_PWM)
    230          void zclSampleLight_UpdateLampLevel( uint8 level );
    231          #endif
    232          
    233          // Functions to process ZCL Foundation incoming Command/Response messages
    234          static void zclSampleLight_ProcessIncomingMsg( zclIncomingMsg_t *msg );
    235          #ifdef ZCL_READ
    236          static uint8 zclSampleLight_ProcessInReadRspCmd( zclIncomingMsg_t *pInMsg );
    237          #endif
    238          #ifdef ZCL_WRITE
    239          static uint8 zclSampleLight_ProcessInWriteRspCmd( zclIncomingMsg_t *pInMsg );
    240          #endif
    241          static uint8 zclSampleLight_ProcessInDefaultRspCmd( zclIncomingMsg_t *pInMsg );
    242          #ifdef ZCL_DISCOVER
    243          static uint8 zclSampleLight_ProcessInDiscCmdsRspCmd( zclIncomingMsg_t *pInMsg );
    244          static uint8 zclSampleLight_ProcessInDiscAttrsRspCmd( zclIncomingMsg_t *pInMsg );
    245          static uint8 zclSampleLight_ProcessInDiscAttrsExtRspCmd( zclIncomingMsg_t *pInMsg );
    246          #endif
    247          
    248          /*********************************************************************
    249           * STATUS STRINGS
    250           */
    251          #ifdef LCD_SUPPORTED

   \                                 In  segment XDATA_ROM_C, align 1
    252          const char sDeviceName[]   = "  Sample Light";
   \                     sDeviceName:
   \   000000   20205361     DB "  Sample Light"
   \            6D706C65
   \            204C6967
   \            687400  

   \                                 In  segment XDATA_ROM_C, align 1
    253          const char sClearLine[]    = " ";
   \                     sClearLine:
   \   000000   2000         DB " "

   \                                 In  segment XDATA_ROM_C, align 1
    254          const char sSwLight[]      = "SW1: ToggleLight";  // 16 chars max
   \                     sSwLight:
   \   000000   5357313A     DB "SW1: ToggleLight"
   \            20546F67
   \            676C654C
   \            69676874
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
    255          const char sSwEZMode[]     = "SW2: EZ-Mode";
   \                     sSwEZMode:
   \   000000   5357323A     DB "SW2: EZ-Mode"
   \            20455A2D
   \            4D6F6465
   \            00      

   \                                 In  segment XDATA_I, align 1, keep-with-next
    256          char sSwHelp[]             = "SW5: Help       ";  // last character is * if NWK open
   \                     sSwHelp:
   \   000000                DS 17
   \   000011                REQUIRE `?<Initializer for sSwHelp>`
   \   000011                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ROM_C, align 1
    257          const char sLightOn[]      = "    LIGHT ON ";
   \                     sLightOn:
   \   000000   20202020     DB "    LIGHT ON "
   \            4C494748
   \            54204F4E
   \            2000    

   \                                 In  segment XDATA_ROM_C, align 1
    258          const char sLightOff[]     = "    LIGHT OFF";
   \                     sLightOff:
   \   000000   20202020     DB "    LIGHT OFF"
   \            4C494748
   \            54204F46
   \            4600    
    259           #if ZCL_LEVEL_CTRL
    260           char sLightLevel[]        = "    LEVEL ###"; // displays level 1-254
    261           #endif
    262          #endif
    263          
    264          /*********************************************************************
    265           * ZCL General Profile Callback table
    266           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
    267          static zclGeneral_AppCallbacks_t zclSampleLight_CmdCallbacks =
   \                     zclSampleLight_CmdCallbacks:
   \   000000                DS 20
   \   000014                REQUIRE `?<Initializer for zclSampleLight_CmdCallbacks>`
   \   000014                REQUIRE __INIT_XDATA_I
    268          {
    269            zclSampleLight_BasicResetCB,            // Basic Cluster Reset command
    270            zclSampleLight_IdentifyCB,              // Identify command
    271          #ifdef ZCL_EZMODE
    272            NULL,                                   // Identify EZ-Mode Invoke command
    273            NULL,                                   // Identify Update Commission State command
    274          #endif
    275            NULL,                                   // Identify Trigger Effect command
    276            zclSampleLight_IdentifyQueryRspCB,      // Identify Query Response command
    277            zclSampleLight_OnOffCB,                 // On/Off cluster commands
    278            NULL,                                   // On/Off cluster enhanced command Off with Effect
    279            NULL,                                   // On/Off cluster enhanced command On with Recall Global Scene
    280            NULL,                                   // On/Off cluster enhanced command On with Timed Off
    281          #ifdef ZCL_LEVEL_CTRL
    282            zclSampleLight_LevelControlMoveToLevelCB, // Level Control Move to Level command
    283            zclSampleLight_LevelControlMoveCB,        // Level Control Move command
    284            zclSampleLight_LevelControlStepCB,        // Level Control Step command
    285            zclSampleLight_LevelControlStopCB,        // Level Control Stop command
    286          #endif
    287          #ifdef ZCL_GROUPS
    288            NULL,                                   // Group Response commands
    289          #endif
    290          #ifdef ZCL_SCENES
    291            NULL,                                  // Scene Store Request command
    292            NULL,                                  // Scene Recall Request command
    293            NULL,                                  // Scene Response command
    294          #endif
    295          #ifdef ZCL_ALARMS
    296            NULL,                                  // Alarm (Response) commands
    297          #endif
    298          #ifdef SE_UK_EXT
    299            NULL,                                  // Get Event Log command
    300            NULL,                                  // Publish Event Log command
    301          #endif
    302            NULL,                                  // RSSI Location command
    303            NULL                                   // RSSI Location Response command
    304          };
    305          
    306          /*********************************************************************
    307           * @fn          zclSampleLight_Init
    308           *
    309           * @brief       Initialization function for the zclGeneral layer.
    310           *
    311           * @param       none
    312           *
    313           * @return      none
    314           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    315          void zclSampleLight_Init( byte task_id )
   \                     zclSampleLight_Init:
    316          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
    317            zclSampleLight_TaskID = task_id;
   \   000007   90....       MOV       DPTR,#zclSampleLight_TaskID
   \   00000A   F0           MOVX      @DPTR,A
    318            
    319            /* Initial UART @Peter */
    320            MT_UartInit();
   \   00000B                ; Setup parameters for call to function MT_UartInit
   \   00000B   12....       LCALL     `??MT_UartInit::?relay`; Banked call to: MT_UartInit
    321            MT_UartRegisterTaskID(task_id);
   \   00000E                ; Setup parameters for call to function MT_UartRegisterTaskID
   \   00000E   EE           MOV       A,R6
   \   00000F   F9           MOV       R1,A
   \   000010   12....       LCALL     `??MT_UartRegisterTaskID::?relay`; Banked call to: MT_UartRegisterTaskID
    322            HalUARTWrite(0, "UartInit OK\n", sizeof("UartInit OK\n"));
   \   000013                ; Setup parameters for call to function HalUARTWrite
   \   000013   7C0D         MOV       R4,#0xd
   \   000015   7D00         MOV       R5,#0x0
   \   000017   7A..         MOV       R2,#`?<Constant "UartInit OK\\n">` & 0xff
   \   000019   7B..         MOV       R3,#(`?<Constant "UartInit OK\\n">` >> 8) & 0xff
   \   00001B   7900         MOV       R1,#0x0
   \   00001D   12....       LCALL     `??HalUARTWrite::?relay`; Banked call to: HalUARTWrite
    323          
    324            // Set destination address to indirect
    325            zclSampleLight_DstAddr.addrMode = (afAddrMode_t)AddrNotPresent;
   \   000020   90....       MOV       DPTR,#zclSampleLight_DstAddr + 8
   \   000023   E4           CLR       A
   \   000024   F0           MOVX      @DPTR,A
    326            zclSampleLight_DstAddr.endPoint = 0;
   \   000025   A3           INC       DPTR
   \   000026   F0           MOVX      @DPTR,A
    327            zclSampleLight_DstAddr.addr.shortAddr = 0;
   \   000027   90....       MOV       DPTR,#zclSampleLight_DstAddr
   \   00002A   F0           MOVX      @DPTR,A
   \   00002B   A3           INC       DPTR
   \   00002C   F0           MOVX      @DPTR,A
    328          
    329            // This app is part of the Home Automation Profile
    330            zclHA_Init( &zclSampleLight_SimpleDesc );
   \   00002D                ; Setup parameters for call to function zclHA_Init
   \   00002D   7A..         MOV       R2,#zclSampleLight_SimpleDesc & 0xff
   \   00002F   7B..         MOV       R3,#(zclSampleLight_SimpleDesc >> 8) & 0xff
   \   000031   12....       LCALL     `??zclHA_Init::?relay`; Banked call to: zclHA_Init
    331          
    332            // Register the ZCL General Cluster Library callback functions
    333            zclGeneral_RegisterCmdCallbacks( SAMPLELIGHT_ENDPOINT, &zclSampleLight_CmdCallbacks );
   \   000034                ; Setup parameters for call to function zclGeneral_RegisterCmdCallbacks
   \   000034   7A..         MOV       R2,#zclSampleLight_CmdCallbacks & 0xff
   \   000036   7B..         MOV       R3,#(zclSampleLight_CmdCallbacks >> 8) & 0xff
   \   000038   7908         MOV       R1,#0x8
   \   00003A   12....       LCALL     `??zclGeneral_RegisterCmdCallbacks::?relay`; Banked call to: zclGeneral_RegisterCmdCallbacks
    334          
    335            // Register the application's attribute list
    336            zcl_registerAttrList( SAMPLELIGHT_ENDPOINT, zclSampleLight_NumAttributes, zclSampleLight_Attrs );
   \   00003D                ; Setup parameters for call to function zcl_registerAttrList
   \   00003D   7C..         MOV       R4,#zclSampleLight_Attrs & 0xff
   \   00003F   7D..         MOV       R5,#(zclSampleLight_Attrs >> 8) & 0xff
   \   000041   90....       MOV       DPTR,#zclSampleLight_NumAttributes
   \   000044   E4           CLR       A
   \   000045   93           MOVC      A,@A+DPTR
   \   000046   FA           MOV       R2,A
   \   000047   7908         MOV       R1,#0x8
   \   000049   12....       LCALL     `??zcl_registerAttrList::?relay`; Banked call to: zcl_registerAttrList
    337          
    338            // Register the Application to receive the unprocessed Foundation command/response messages
    339            zcl_registerForMsg( zclSampleLight_TaskID );
   \   00004C                ; Setup parameters for call to function zcl_registerForMsg
   \   00004C   90....       MOV       DPTR,#zclSampleLight_TaskID
   \   00004F   E0           MOVX      A,@DPTR
   \   000050   F9           MOV       R1,A
   \   000051   12....       LCALL     `??zcl_registerForMsg::?relay`; Banked call to: zcl_registerForMsg
    340          
    341          #ifdef ZCL_DISCOVER
    342            // Register the application's command list
    343            zcl_registerCmdList( SAMPLELIGHT_ENDPOINT, zclCmdsArraySize, zclSampleLight_Cmds );
    344          #endif
    345          
    346            // Register for all key events - This app will handle all key events
    347            RegisterForKeys( zclSampleLight_TaskID );
   \   000054                ; Setup parameters for call to function RegisterForKeys
   \   000054   90....       MOV       DPTR,#zclSampleLight_TaskID
   \   000057   E0           MOVX      A,@DPTR
   \   000058   F9           MOV       R1,A
   \   000059   12....       LCALL     `??RegisterForKeys::?relay`; Banked call to: RegisterForKeys
    348          
    349            // Register for a test endpoint
    350            afRegister( &sampleLight_TestEp );
   \   00005C                ; Setup parameters for call to function afRegister
   \   00005C   7A..         MOV       R2,#sampleLight_TestEp & 0xff
   \   00005E   7B..         MOV       R3,#(sampleLight_TestEp >> 8) & 0xff
   \   000060   12....       LCALL     `??afRegister::?relay`; Banked call to: afRegister
    351          
    352          #ifdef ZCL_EZMODE
    353            // Register EZ-Mode
    354            zcl_RegisterEZMode( &zclSampleLight_RegisterEZModeData );
    355          
    356            // Register with the ZDO to receive Match Descriptor Responses
    357            ZDO_RegisterForZDOMsg(task_id, Match_Desc_rsp);
    358          #endif
    359          
    360          
    361          #if (defined HAL_BOARD_ZLIGHT) || (defined HAL_PWM)
    362            HalTimer1Init( 0 );
    363            halTimer1SetChannelDuty( WHITE_LED, 0 );
    364            halTimer1SetChannelDuty( RED_LED, 0 );
    365            halTimer1SetChannelDuty( BLUE_LED, 0 );
    366            halTimer1SetChannelDuty( GREEN_LED, 0 );
    367          
    368            // find if we are already on a network from NV_RESTORE
    369            uint8 state;
    370            NLME_GetRequest( nwkNwkState, 0, &state );
    371          
    372            if ( state < NWK_ENDDEVICE )
    373            {
    374              // Start EZMode on Start up to avoid button press
    375              osal_start_timerEx( zclSampleLight_TaskID, SAMPLELIGHT_START_EZMODE_EVT, 500 );
    376            }
    377          #if ZCL_LEVEL_CTRL
    378            zclSampleLight_DefaultMove();
    379          #endif
    380          #endif // #if (defined HAL_BOARD_ZLIGHT) || (defined HAL_PWM)
    381          
    382          #ifdef ZCL_DIAGNOSTIC
    383            // Register the application's callback function to read/write attribute data.
    384            // This is only required when the attribute data format is unknown to ZCL.
    385            zcl_registerReadWriteCB( SAMPLELIGHT_ENDPOINT, zclDiagnostic_ReadWriteAttrCB, NULL );
    386          
    387            if ( zclDiagnostic_InitStats() == ZSuccess )
    388            {
    389              // Here the user could start the timer to save Diagnostics to NV
    390            }
    391          #endif
    392          
    393          #ifdef LCD_SUPPORTED
    394            HalLcdWriteString ( (char *)sDeviceName, HAL_LCD_LINE_3 );
   \   000063                ; Setup parameters for call to function HalLcdWriteString
   \   000063   7903         MOV       R1,#0x3
   \   000065   7A..         MOV       R2,#sDeviceName & 0xff
   \   000067   7B..         MOV       R3,#(sDeviceName >> 8) & 0xff
   \   000069   12....       LCALL     `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
    395          #endif  // LCD_SUPPORTED
    396          
    397          #ifdef ZGP_AUTO_TT
    398            zgpTranslationTable_RegisterEP ( &zclSampleLight_SimpleDesc );
    399          #endif
    400          }
   \   00006C   7F01         MOV       R7,#0x1
   \   00006E   02....       LJMP      ?BANKED_LEAVE_XDATA
    401          
    402          /*********************************************************************
    403           * @fn          zclSample_event_loop
    404           *
    405           * @brief       Event Loop Processor for zclGeneral.
    406           *
    407           * @param       none
    408           *
    409           * @return      none
    410           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    411          uint16 zclSampleLight_event_loop( uint8 task_id, uint16 events )
   \                     zclSampleLight_event_loop:
    412          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    413            afIncomingMSGPacket_t *MSGpkt;
    414          
    415            (void)task_id;  // Intentionally unreferenced parameter
    416          
    417            if ( events & SYS_EVENT_MSG )
   \   000009   5480         ANL       A,#0x80
   \   00000B   7047         JNZ       ??zclSampleLight_event_loop_0
    418            {
    419              while ( (MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( zclSampleLight_TaskID )) )
    420              {
    421                switch ( MSGpkt->hdr.event )
    422                {
    423          #ifdef ZCL_EZMODE
    424                  case ZDO_CB_MSG:
    425                    zclSampleLight_ProcessZDOMsgs( (zdoIncomingMsg_t *)MSGpkt );
    426                    break;
    427          #endif
    428                  case ZCL_INCOMING_MSG:
    429                    // Incoming ZCL Foundation command/response messages
    430                    zclSampleLight_ProcessIncomingMsg( (zclIncomingMsg_t *)MSGpkt );
    431                    break;
    432          
    433                  case KEY_CHANGE:
    434                    zclSampleLight_HandleKeys( ((keyChange_t *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys );
    435                    break;
    436          
    437                  case ZDO_STATE_CHANGE:
    438                    zclSampleLight_NwkState = (devStates_t)(MSGpkt->hdr.status);
    439          
    440                    // now on the network
    441                    if ( (zclSampleLight_NwkState == DEV_ZB_COORD) ||
    442                         (zclSampleLight_NwkState == DEV_ROUTER)   ||
    443                         (zclSampleLight_NwkState == DEV_END_DEVICE) )
    444                    {
    445                      giLightScreenMode = LIGHT_MAINMODE;
    446                      zclSampleLight_LcdDisplayUpdate();
    447          #ifdef ZCL_EZMODE
    448                      zcl_EZModeAction( EZMODE_ACTION_NETWORK_STARTED, NULL );
    449          #endif // ZCL_EZMODE
    450                    }
    451                    break;
    452          
    453                  default:
    454                    break;
    455                }
    456          
    457                // Release the memory
    458                osal_msg_deallocate( (uint8 *)MSGpkt );
    459              }
    460          
    461              // return unprocessed events
    462              return (events ^ SYS_EVENT_MSG);
    463            }
    464          
    465            if ( events & SAMPLELIGHT_IDENTIFY_TIMEOUT_EVT )
   \   00000D   EA           MOV       A,R2
   \   00000E   A2E0         MOV       C,0xE0 /* A   */.0
   \   000010   4003         JC        $+5
   \   000012   02....       LJMP      ??zclSampleLight_event_loop_1 & 0xFFFF
    466            {
    467              if ( zclSampleLight_IdentifyTime > 0 )
   \   000015   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000018   E8           MOV       A,R0
   \   000019   49           ORL       A,R1
   \   00001A   600C         JZ        ??zclSampleLight_event_loop_2
    468                zclSampleLight_IdentifyTime--;
   \   00001C   90....       MOV       DPTR,#zclSampleLight_IdentifyTime
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   24FF         ADD       A,#-0x1
   \   000022   F0           MOVX      @DPTR,A
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   34FF         ADDC      A,#-0x1
   \   000027   F0           MOVX      @DPTR,A
    469              zclSampleLight_ProcessIdentifyTimeChange();
   \                     ??zclSampleLight_event_loop_2:
   \   000028                ; Setup parameters for call to function zclSampleLight_ProcessIdentifyTimeChange
   \   000028   12....       LCALL     `??zclSampleLight_ProcessIdentifyTimeChange::?re`; Banked call to: zclSampleLight_ProcessIdentifyTimeChange
    470          
    471              return ( events ^ SAMPLELIGHT_IDENTIFY_TIMEOUT_EVT );
   \   00002B   EE           MOV       A,R6
   \   00002C   6401         XRL       A,#0x1
   \   00002E   02....       LJMP      ??zclSampleLight_event_loop_3 & 0xFFFF
    472            }
   \                     ??zclSampleLight_event_loop_4:
   \   000031   A3           INC       DPTR
   \   000032   E0           MOVX      A,@DPTR
   \   000033   90....       MOV       DPTR,#zclSampleLight_NwkState
   \   000036   F0           MOVX      @DPTR,A
   \   000037   6409         XRL       A,#0x9
   \   000039   600A         JZ        ??zclSampleLight_event_loop_5
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   6407         XRL       A,#0x7
   \   00003E   6005         JZ        ??zclSampleLight_event_loop_5
   \   000040   E0           MOVX      A,@DPTR
   \   000041   6406         XRL       A,#0x6
   \   000043   7008         JNZ       ??zclSampleLight_event_loop_6
   \                     ??zclSampleLight_event_loop_5:
   \   000045   90....       MOV       DPTR,#giLightScreenMode
   \   000048   E4           CLR       A
   \   000049   F0           MOVX      @DPTR,A
   \   00004A                ; Setup parameters for call to function zclSampleLight_LcdDisplayUpdate
   \   00004A   12....       LCALL     `??zclSampleLight_LcdDisplayUpdate::?relay`; Banked call to: zclSampleLight_LcdDisplayUpdate
   \                     ??zclSampleLight_event_loop_6:
   \   00004D                ; Setup parameters for call to function osal_msg_deallocate
   \   00004D   AA..         MOV       R2,?V0
   \   00004F   AB..         MOV       R3,?V1
   \   000051   12....       LCALL     `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
   \                     ??zclSampleLight_event_loop_0:
   \   000054                ; Setup parameters for call to function osal_msg_receive
   \   000054   90....       MOV       DPTR,#zclSampleLight_TaskID
   \   000057   E0           MOVX      A,@DPTR
   \   000058   F9           MOV       R1,A
   \   000059   12....       LCALL     `??osal_msg_receive::?relay`; Banked call to: osal_msg_receive
   \   00005C   8A..         MOV       ?V0,R2
   \   00005E   8B..         MOV       ?V1,R3
   \   000060   EA           MOV       A,R2
   \   000061   4B           ORL       A,R3
   \   000062   603E         JZ        ??zclSampleLight_event_loop_7
   \   000064   8A82         MOV       DPL,R2
   \   000066   8B83         MOV       DPH,R3
   \   000068   E0           MOVX      A,@DPTR
   \   000069   24CC         ADD       A,#-0x34
   \   00006B   600A         JZ        ??zclSampleLight_event_loop_8
   \   00006D   2474         ADD       A,#0x74
   \   00006F   601E         JZ        ??zclSampleLight_event_loop_9
   \   000071   24EF         ADD       A,#-0x11
   \   000073   60BC         JZ        ??zclSampleLight_event_loop_4
   \   000075   80D6         SJMP      ??zclSampleLight_event_loop_6
   \                     ??zclSampleLight_event_loop_8:
   \   000077   EA           MOV       A,R2
   \   000078   2417         ADD       A,#0x17
   \   00007A   F582         MOV       DPL,A
   \   00007C   E4           CLR       A
   \   00007D   35..         ADDC      A,?V1
   \   00007F   F583         MOV       DPH,A
   \   000081   E0           MOVX      A,@DPTR
   \   000082   FA           MOV       R2,A
   \   000083   A3           INC       DPTR
   \   000084   E0           MOVX      A,@DPTR
   \   000085   FB           MOV       R3,A
   \   000086   EA           MOV       A,R2
   \   000087   4B           ORL       A,R3
   \   000088   60C3         JZ        ??zclSampleLight_event_loop_6
   \   00008A                ; Setup parameters for call to function osal_mem_free
   \   00008A   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   00008D   80BE         SJMP      ??zclSampleLight_event_loop_6
   \                     ??zclSampleLight_event_loop_9:
   \   00008F                ; Setup parameters for call to function zclSampleLight_HandleKeys
   \   00008F   A3           INC       DPTR
   \   000090   A3           INC       DPTR
   \   000091   A3           INC       DPTR
   \   000092   E0           MOVX      A,@DPTR
   \   000093   FA           MOV       R2,A
   \   000094   85..82       MOV       DPL,?V0
   \   000097   8B83         MOV       DPH,R3
   \   000099   A3           INC       DPTR
   \   00009A   A3           INC       DPTR
   \   00009B   E0           MOVX      A,@DPTR
   \   00009C   F9           MOV       R1,A
   \   00009D   12....       LCALL     `??zclSampleLight_HandleKeys::?relay`; Banked call to: zclSampleLight_HandleKeys
   \   0000A0   80AB         SJMP      ??zclSampleLight_event_loop_6
   \                     ??zclSampleLight_event_loop_7:
   \   0000A2   EE           MOV       A,R6
   \   0000A3   FA           MOV       R2,A
   \   0000A4   EF           MOV       A,R7
   \   0000A5   6480         XRL       A,#0x80
   \   0000A7   8011         SJMP      ??zclSampleLight_event_loop_10
    473          
    474            if ( events & SAMPLELIGHT_MAIN_SCREEN_EVT )
   \                     ??zclSampleLight_event_loop_1:
   \   0000A9   5410         ANL       A,#0x10
   \   0000AB   6010         JZ        ??zclSampleLight_event_loop_11
    475            {
    476              giLightScreenMode = LIGHT_MAINMODE;
   \   0000AD   90....       MOV       DPTR,#giLightScreenMode
   \   0000B0   E4           CLR       A
   \   0000B1   F0           MOVX      @DPTR,A
    477              zclSampleLight_LcdDisplayUpdate();
   \   0000B2                ; Setup parameters for call to function zclSampleLight_LcdDisplayUpdate
   \   0000B2   12....       LCALL     `??zclSampleLight_LcdDisplayUpdate::?relay`; Banked call to: zclSampleLight_LcdDisplayUpdate
    478          
    479              return ( events ^ SAMPLELIGHT_MAIN_SCREEN_EVT );
   \   0000B5   EE           MOV       A,R6
   \   0000B6   6410         XRL       A,#0x10
   \                     ??zclSampleLight_event_loop_3:
   \   0000B8   FA           MOV       R2,A
   \   0000B9   EF           MOV       A,R7
   \                     ??zclSampleLight_event_loop_10:
   \   0000BA   FB           MOV       R3,A
   \   0000BB   8004         SJMP      ??zclSampleLight_event_loop_12
    480            }
    481          
    482          #ifdef ZCL_EZMODE
    483          #if (defined HAL_BOARD_ZLIGHT)
    484            // event to start EZMode on startup with a delay
    485            if ( events & SAMPLELIGHT_START_EZMODE_EVT )
    486            {
    487              // Invoke EZ-Mode
    488              zclEZMode_InvokeData_t ezModeData;
    489          
    490              // Invoke EZ-Mode
    491              ezModeData.endpoint = SAMPLELIGHT_ENDPOINT; // endpoint on which to invoke EZ-Mode
    492              if ( (zclSampleLight_NwkState == DEV_ZB_COORD) ||
    493                   (zclSampleLight_NwkState == DEV_ROUTER)   ||
    494                   (zclSampleLight_NwkState == DEV_END_DEVICE) )
    495              {
    496                ezModeData.onNetwork = TRUE;      // node is already on the network
    497              }
    498              else
    499              {
    500                ezModeData.onNetwork = FALSE;     // node is not yet on the network
    501              }
    502              ezModeData.initiator = FALSE;          // OnOffLight is a target
    503              ezModeData.numActiveOutClusters = 0;
    504              ezModeData.pActiveOutClusterIDs = NULL;
    505              ezModeData.numActiveInClusters = 0;
    506              ezModeData.pActiveOutClusterIDs = NULL;
    507              zcl_InvokeEZMode( &ezModeData );
    508          
    509              return ( events ^ SAMPLELIGHT_START_EZMODE_EVT );
    510            }
    511          #endif // #if (defined HAL_BOARD_ZLIGHT)
    512          
    513            // going on to next state
    514            if ( events & SAMPLELIGHT_EZMODE_NEXTSTATE_EVT )
    515            {
    516              zcl_EZModeAction ( EZMODE_ACTION_PROCESS, NULL );   // going on to next state
    517              return ( events ^ SAMPLELIGHT_EZMODE_NEXTSTATE_EVT );
    518            }
    519          
    520            // the overall EZMode timer expired, so we timed out
    521            if ( events & SAMPLELIGHT_EZMODE_TIMEOUT_EVT )
    522            {
    523              zcl_EZModeAction ( EZMODE_ACTION_TIMED_OUT, NULL ); // EZ-Mode timed out
    524              return ( events ^ SAMPLELIGHT_EZMODE_TIMEOUT_EVT );
    525            }
    526          #endif // ZLC_EZMODE
    527          
    528          #ifdef ZCL_LEVEL_CTRL
    529            if ( events & SAMPLELIGHT_LEVEL_CTRL_EVT )
    530            {
    531              zclSampleLight_AdjustLightLevel();
    532              return ( events ^ SAMPLELIGHT_LEVEL_CTRL_EVT );
    533            }
    534          #endif
    535          
    536            // Discard unknown events
    537            return 0;
   \                     ??zclSampleLight_event_loop_11:
   \   0000BD   7A00         MOV       R2,#0x0
   \   0000BF   7B00         MOV       R3,#0x0
   \                     ??zclSampleLight_event_loop_12:
   \   0000C1   7F04         MOV       R7,#0x4
   \   0000C3   02....       LJMP      ?BANKED_LEAVE_XDATA
    538          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   90....       MOV       DPTR,#zclSampleLight_IdentifyTime
   \   000003                REQUIRE ??Subroutine4_0
   \   000003                ; // Fall through to label ??Subroutine4_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine4_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   22           RET
    539          
    540          /*********************************************************************
    541           * @fn      zclSampleLight_HandleKeys
    542           *
    543           * @brief   Handles all key events for this device.
    544           *
    545           * @param   shift - true if in shift/alt.
    546           * @param   keys - bit field for key events. Valid entries:
    547           *                 HAL_KEY_SW_5
    548           *                 HAL_KEY_SW_4
    549           *                 HAL_KEY_SW_2
    550           *                 HAL_KEY_SW_1
    551           *
    552           * @return  none
    553           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    554          static void zclSampleLight_HandleKeys( byte shift, byte keys )
   \                     zclSampleLight_HandleKeys:
    555          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV       A,#-0x9
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   \   00000C   EA           MOV       A,R2
   \   00000D   FF           MOV       R7,A
    556            if ( keys & HAL_KEY_SW_1 )
   \   00000E   A2E0         MOV       C,0xE0 /* A   */.0
   \   000010   5011         JNC       ??zclSampleLight_HandleKeys_0
    557            {
    558              giLightScreenMode = LIGHT_MAINMODE;
   \   000012   90....       MOV       DPTR,#giLightScreenMode
   \   000015   E4           CLR       A
   \   000016   F0           MOVX      @DPTR,A
    559          
    560              // toggle local light immediately
    561              zclSampleLight_OnOff = zclSampleLight_OnOff ? LIGHT_OFF : LIGHT_ON;
   \   000017   90....       MOV       DPTR,#zclSampleLight_OnOff
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   6003         JZ        ??zclSampleLight_HandleKeys_1
   \   00001D   E4           CLR       A
   \   00001E   8002         SJMP      ??zclSampleLight_HandleKeys_2
   \                     ??zclSampleLight_HandleKeys_1:
   \   000020   7401         MOV       A,#0x1
   \                     ??zclSampleLight_HandleKeys_2:
   \   000022   F0           MOVX      @DPTR,A
    562          #ifdef ZCL_LEVEL_CTRL
    563              zclSampleLight_LevelCurrentLevel = zclSampleLight_OnOff ? zclSampleLight_LevelOnLevel : ATTR_LEVEL_MIN_LEVEL;
    564          #endif
    565            }
    566          
    567            if ( keys & HAL_KEY_SW_2 )
   \                     ??zclSampleLight_HandleKeys_0:
   \   000023   EA           MOV       A,R2
   \   000024   A2E1         MOV       C,0xE0 /* A   */.1
   \   000026   5064         JNC       ??zclSampleLight_HandleKeys_3
    568            {
    569          #if (defined HAL_BOARD_ZLIGHT)
    570          
    571              zclSampleLight_BasicResetCB();
    572          
    573          #else
    574          
    575              giLightScreenMode = LIGHT_MAINMODE;
   \   000028   90....       MOV       DPTR,#giLightScreenMode
   \   00002B   E4           CLR       A
   \   00002C   F0           MOVX      @DPTR,A
    576          
    577          #ifdef ZCL_EZMODE
    578              {
    579                // Invoke EZ-Mode
    580                zclEZMode_InvokeData_t ezModeData;
    581          
    582                // Invoke EZ-Mode
    583                ezModeData.endpoint = SAMPLELIGHT_ENDPOINT; // endpoint on which to invoke EZ-Mode
    584                if ( (zclSampleLight_NwkState == DEV_ZB_COORD) ||
    585                    (zclSampleLight_NwkState == DEV_ROUTER)   ||
    586                      (zclSampleLight_NwkState == DEV_END_DEVICE) )
    587                {
    588                  ezModeData.onNetwork = TRUE;      // node is already on the network
    589                }
    590                else
    591                {
    592                  ezModeData.onNetwork = FALSE;     // node is not yet on the network
    593                }
    594                ezModeData.initiator = FALSE;          // OnOffLight is a target
    595                ezModeData.numActiveOutClusters = 0;
    596                ezModeData.pActiveOutClusterIDs = NULL;
    597                ezModeData.numActiveInClusters = 0;
    598                ezModeData.pActiveOutClusterIDs = NULL;
    599                zcl_InvokeEZMode( &ezModeData );
    600              }
    601          
    602          #else // NOT EZ-Mode
    603              {
    604                zAddrType_t dstAddr;
    605                HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
   \   00002D                ; Setup parameters for call to function HalLedSet
   \   00002D   FA           MOV       R2,A
   \   00002E   7908         MOV       R1,#0x8
   \   000030   12....       LCALL     `??HalLedSet::?relay`; Banked call to: HalLedSet
    606          
    607                // Initiate an End Device Bind Request, this bind request will
    608                // only use a cluster list that is important to binding.
    609                dstAddr.addrMode = afAddr16Bit;
   \   000033   7408         MOV       A,#0x8
   \   000035   12....       LCALL     ?XSTACK_DISP0_8
   \   000038   7402         MOV       A,#0x2
   \   00003A   F0           MOVX      @DPTR,A
    610                dstAddr.addr.shortAddr = 0;   // Coordinator makes the match
   \   00003B   85..82       MOV       DPL,?XSP + 0
   \   00003E   85..83       MOV       DPH,?XSP + 1
   \   000041   E4           CLR       A
   \   000042   F0           MOVX      @DPTR,A
   \   000043   A3           INC       DPTR
   \   000044   F0           MOVX      @DPTR,A
    611                ZDP_EndDeviceBindReq( &dstAddr, NLME_GetShortAddr(),
    612                                     SAMPLELIGHT_ENDPOINT,
    613                                     ZCL_HA_PROFILE_ID,
    614                                     ZCLSAMPLELIGHT_BINDINGLIST, bindingInClusters,
    615                                     0, NULL,   // No Outgoing clusters to bind
    616                                     TRUE );
   \   000045                ; Setup parameters for call to function NLME_GetShortAddr
   \   000045   12....       LCALL     ?Subroutine2 & 0xFFFF
    617              }
    618          #endif // ZCL_EZMODE
    619          #endif // HAL_BOARD_ZLIGHT
    620            }
   \                     ??CrossCallReturnLabel_0:
   \   000048                ; Setup parameters for call to function ZDP_EndDeviceBindReq
   \   000048   75..01       MOV       ?V0,#0x1
   \   00004B   78..         MOV       R0,#?V0
   \   00004D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000050   E4           CLR       A
   \   000051   F5..         MOV       ?V0,A
   \   000053   F5..         MOV       ?V1,A
   \   000055   78..         MOV       R0,#?V0
   \   000057   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005A   78..         MOV       R0,#?V0
   \   00005C   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00005F   75....       MOV       ?V0,#bindingInClusters & 0xff
   \   000062   75....       MOV       ?V1,#(bindingInClusters >> 8) & 0xff
   \   000065   78..         MOV       R0,#?V0
   \   000067   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006A   75..01       MOV       ?V0,#0x1
   \   00006D   78..         MOV       R0,#?V0
   \   00006F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000072   75..04       MOV       ?V0,#0x4
   \   000075   75..01       MOV       ?V1,#0x1
   \   000078   78..         MOV       R0,#?V0
   \   00007A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00007D   7908         MOV       R1,#0x8
   \   00007F   7409         MOV       A,#0x9
   \   000081   12....       LCALL     ?XSTACK_DISP101_8
   \   000084   12....       LCALL     `??ZDP_EndDeviceBindReq::?relay`; Banked call to: ZDP_EndDeviceBindReq
   \   000087   7409         MOV       A,#0x9
   \   000089   12....       LCALL     ?DEALLOC_XSTACK8
    621          
    622            if ( keys & HAL_KEY_SW_3 )
   \                     ??zclSampleLight_HandleKeys_3:
   \   00008C   EF           MOV       A,R7
   \   00008D   A2E4         MOV       C,0xE0 /* A   */.4
   \   00008F   501D         JNC       ??zclSampleLight_HandleKeys_4
    623            {
    624              NLME_SendNetworkStatus( zclSampleLight_DstAddr.addr.shortAddr,
    625                                 NLME_GetShortAddr(), NWKSTAT_NONTREE_LINK_FAILURE, FALSE );
   \   000091                ; Setup parameters for call to function NLME_GetShortAddr
   \   000091   12....       LCALL     ?Subroutine2 & 0xFFFF
    626            }
   \                     ??CrossCallReturnLabel_1:
   \   000094                ; Setup parameters for call to function NLME_SendNetworkStatus
   \   000094   75..00       MOV       ?V0,#0x0
   \   000097   78..         MOV       R0,#?V0
   \   000099   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00009C   7902         MOV       R1,#0x2
   \   00009E   90....       MOV       DPTR,#zclSampleLight_DstAddr
   \   0000A1   E0           MOVX      A,@DPTR
   \   0000A2   FA           MOV       R2,A
   \   0000A3   A3           INC       DPTR
   \   0000A4   E0           MOVX      A,@DPTR
   \   0000A5   FB           MOV       R3,A
   \   0000A6   12....       LCALL     `??NLME_SendNetworkStatus::?relay`; Banked call to: NLME_SendNetworkStatus
   \   0000A9   7401         MOV       A,#0x1
   \   0000AB   12....       LCALL     ?DEALLOC_XSTACK8
    627          
    628            if ( keys & HAL_KEY_SW_4 )
   \                     ??zclSampleLight_HandleKeys_4:
   \   0000AE   EF           MOV       A,R7
   \   0000AF   A2E3         MOV       C,0xE0 /* A   */.3
   \   0000B1   5041         JNC       ??zclSampleLight_HandleKeys_5
    629            {
    630              giLightScreenMode = LIGHT_MAINMODE;
   \   0000B3   90....       MOV       DPTR,#giLightScreenMode
   \   0000B6   E4           CLR       A
   \   0000B7   F0           MOVX      @DPTR,A
    631          
    632              if ( ( zclSampleLight_NwkState == DEV_ZB_COORD ) ||
    633                    ( zclSampleLight_NwkState == DEV_ROUTER ) )
   \   0000B8   90....       MOV       DPTR,#zclSampleLight_NwkState
   \   0000BB   E0           MOVX      A,@DPTR
   \   0000BC   6409         XRL       A,#0x9
   \   0000BE   6005         JZ        ??zclSampleLight_HandleKeys_6
   \   0000C0   E0           MOVX      A,@DPTR
   \   0000C1   6407         XRL       A,#0x7
   \   0000C3   702F         JNZ       ??zclSampleLight_HandleKeys_5
    634              {
    635                zAddrType_t tmpAddr;
    636          
    637                tmpAddr.addrMode = Addr16Bit;
   \                     ??zclSampleLight_HandleKeys_6:
   \   0000C5   7408         MOV       A,#0x8
   \   0000C7   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CA   7402         MOV       A,#0x2
   \   0000CC   F0           MOVX      @DPTR,A
    638                tmpAddr.addr.shortAddr = NLME_GetShortAddr();
   \   0000CD                ; Setup parameters for call to function NLME_GetShortAddr
   \   0000CD   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   0000D0   85..82       MOV       DPL,?XSP + 0
   \   0000D3   85..83       MOV       DPH,?XSP + 1
   \   0000D6   EA           MOV       A,R2
   \   0000D7   F0           MOVX      @DPTR,A
   \   0000D8   A3           INC       DPTR
   \   0000D9   EB           MOV       A,R3
   \   0000DA   F0           MOVX      @DPTR,A
    639          
    640                // toggle permit join
    641                gPermitDuration = gPermitDuration ? 0 : 0xff;
   \   0000DB   90....       MOV       DPTR,#gPermitDuration
   \   0000DE   E0           MOVX      A,@DPTR
   \   0000DF   6003         JZ        ??zclSampleLight_HandleKeys_7
   \   0000E1   E4           CLR       A
   \   0000E2   8002         SJMP      ??zclSampleLight_HandleKeys_8
   \                     ??zclSampleLight_HandleKeys_7:
   \   0000E4   74FF         MOV       A,#-0x1
   \                     ??zclSampleLight_HandleKeys_8:
   \   0000E6   F0           MOVX      @DPTR,A
    642          
    643                // Trust Center significance is always true
    644                ZDP_MgmtPermitJoinReq( &tmpAddr, gPermitDuration, TRUE, FALSE );
   \   0000E7                ; Setup parameters for call to function ZDP_MgmtPermitJoinReq
   \   0000E7   7D00         MOV       R5,#0x0
   \   0000E9   7C01         MOV       R4,#0x1
   \   0000EB   E0           MOVX      A,@DPTR
   \   0000EC   F9           MOV       R1,A
   \   0000ED   AA..         MOV       R2,?XSP + 0
   \   0000EF   AB..         MOV       R3,?XSP + 1
   \   0000F1   12....       LCALL     `??ZDP_MgmtPermitJoinReq::?relay`; Banked call to: ZDP_MgmtPermitJoinReq
    645              }
    646            }
    647          
    648            // Shift F5 does a Basic Reset (factory defaults)
    649            if ( shift && ( keys & HAL_KEY_SW_5 ) )
   \                     ??zclSampleLight_HandleKeys_5:
   \   0000F4   EE           MOV       A,R6
   \   0000F5   600A         JZ        ??zclSampleLight_HandleKeys_9
   \   0000F7   EF           MOV       A,R7
   \   0000F8   A2E2         MOV       C,0xE0 /* A   */.2
   \   0000FA   5016         JNC       ??zclSampleLight_HandleKeys_10
    650            {
    651              zclSampleLight_BasicResetCB();
   \   0000FC                ; Setup parameters for call to function zclSampleLight_BasicResetCB
   \   0000FC   12....       LCALL     `??zclSampleLight_BasicResetCB::?relay`; Banked call to: zclSampleLight_BasicResetCB
   \   0000FF   8011         SJMP      ??zclSampleLight_HandleKeys_10
    652            }
    653            else if ( keys & HAL_KEY_SW_5 )
   \                     ??zclSampleLight_HandleKeys_9:
   \   000101   EF           MOV       A,R7
   \   000102   A2E2         MOV       C,0xE0 /* A   */.2
   \   000104   500C         JNC       ??zclSampleLight_HandleKeys_10
    654            {
    655              giLightScreenMode = giLightScreenMode ? LIGHT_MAINMODE : LIGHT_HELPMODE;
   \   000106   90....       MOV       DPTR,#giLightScreenMode
   \   000109   E0           MOVX      A,@DPTR
   \   00010A   6003         JZ        ??zclSampleLight_HandleKeys_11
   \   00010C   E4           CLR       A
   \   00010D   8002         SJMP      ??zclSampleLight_HandleKeys_12
   \                     ??zclSampleLight_HandleKeys_11:
   \   00010F   7401         MOV       A,#0x1
   \                     ??zclSampleLight_HandleKeys_12:
   \   000111   F0           MOVX      @DPTR,A
    656            }
    657          
    658            // update the display, including the light
    659            zclSampleLight_LcdDisplayUpdate();
   \                     ??zclSampleLight_HandleKeys_10:
   \   000112                ; Setup parameters for call to function zclSampleLight_LcdDisplayUpdate
   \   000112   12....       LCALL     `??zclSampleLight_LcdDisplayUpdate::?relay`; Banked call to: zclSampleLight_LcdDisplayUpdate
    660          }
   \   000115   7409         MOV       A,#0x9
   \   000117   12....       LCALL     ?DEALLOC_XSTACK8
   \   00011A                REQUIRE ?Subroutine0
   \   00011A                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F02         MOV       R7,#0x2
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000003   8A..         MOV       ?V0,R2
   \   000005   8B..         MOV       ?V1,R3
   \   000007   AC..         MOV       R4,?V0
   \   000009   AD..         MOV       R5,?V1
   \   00000B   22           RET
    661          
    662          /*********************************************************************
    663           * @fn      zclSampleLight_LcdDisplayUpdate
    664           *
    665           * @brief   Called to update the LCD display.
    666           *
    667           * @param   none
    668           *
    669           * @return  none
    670           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    671          void zclSampleLight_LcdDisplayUpdate( void )
   \                     zclSampleLight_LcdDisplayUpdate:
    672          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    673          #ifdef LCD_SUPPORTED
    674            if ( giLightScreenMode == LIGHT_HELPMODE )
   \   000004   90....       MOV       DPTR,#giLightScreenMode
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6401         XRL       A,#0x1
   \   00000A   7014         JNZ       ??zclSampleLight_LcdDisplayUpdate_0
    675            {
    676              zclSampleLight_LcdDisplayHelpMode();
   \   00000C                ; Setup parameters for call to function HalLcdWriteString
   \   00000C   7901         MOV       R1,#0x1
   \   00000E   7A..         MOV       R2,#sSwLight & 0xff
   \   000010   7B..         MOV       R3,#(sSwLight >> 8) & 0xff
   \   000012   12....       LCALL     `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
   \   000015                ; Setup parameters for call to function HalLcdWriteString
   \   000015   7902         MOV       R1,#0x2
   \   000017   7A..         MOV       R2,#sSwEZMode & 0xff
   \   000019   7B..         MOV       R3,#(sSwEZMode >> 8) & 0xff
   \   00001B   12....       LCALL     `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
   \   00001E                ; Setup parameters for call to function HalLcdWriteString
   \   00001E   802F         SJMP      ??zclSampleLight_LcdDisplayUpdate_1
    677            }
    678            else
    679            {
    680              zclSampleLight_LcdDisplayMainMode();
   \                     ??zclSampleLight_LcdDisplayUpdate_0:
   \   000020   90....       MOV       DPTR,#zclSampleLight_NwkState
   \   000023   E0           MOVX      A,@DPTR
   \   000024   6409         XRL       A,#0x9
   \   000026   7004         JNZ       ??zclSampleLight_LcdDisplayUpdate_2
   \   000028                ; Setup parameters for call to function zclHA_LcdStatusLine1
   \   000028   7900         MOV       R1,#0x0
   \   00002A   8010         SJMP      ??zclSampleLight_LcdDisplayUpdate_3
   \                     ??zclSampleLight_LcdDisplayUpdate_2:
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   6407         XRL       A,#0x7
   \   00002F   7004         JNZ       ??zclSampleLight_LcdDisplayUpdate_4
   \   000031                ; Setup parameters for call to function zclHA_LcdStatusLine1
   \   000031   7901         MOV       R1,#0x1
   \   000033   8007         SJMP      ??zclSampleLight_LcdDisplayUpdate_3
   \                     ??zclSampleLight_LcdDisplayUpdate_4:
   \   000035   E0           MOVX      A,@DPTR
   \   000036   6406         XRL       A,#0x6
   \   000038   7005         JNZ       ??zclSampleLight_LcdDisplayUpdate_5
   \   00003A                ; Setup parameters for call to function zclHA_LcdStatusLine1
   \   00003A   7902         MOV       R1,#0x2
   \                     ??zclSampleLight_LcdDisplayUpdate_3:
   \   00003C   12....       LCALL     `??zclHA_LcdStatusLine1::?relay`; Banked call to: zclHA_LcdStatusLine1
   \                     ??zclSampleLight_LcdDisplayUpdate_5:
   \   00003F   90....       MOV       DPTR,#gPermitDuration
   \   000042   E0           MOVX      A,@DPTR
   \   000043   90....       MOV       DPTR,#sSwHelp + 15
   \   000046   6004         JZ        ??zclSampleLight_LcdDisplayUpdate_6
   \   000048   742A         MOV       A,#0x2a
   \   00004A   8002         SJMP      ??zclSampleLight_LcdDisplayUpdate_7
   \                     ??zclSampleLight_LcdDisplayUpdate_6:
   \   00004C   7420         MOV       A,#0x20
   \                     ??zclSampleLight_LcdDisplayUpdate_7:
   \   00004E   F0           MOVX      @DPTR,A
   \                     ??zclSampleLight_LcdDisplayUpdate_1:
   \   00004F                ; Setup parameters for call to function HalLcdWriteString
   \   00004F   7903         MOV       R1,#0x3
   \   000051   7A..         MOV       R2,#sSwHelp & 0xff
   \   000053   7B..         MOV       R3,#(sSwHelp >> 8) & 0xff
   \   000055   12....       LCALL     `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
    681            }
    682          #endif
    683          
    684            zclSampleLight_DisplayLight();
   \   000058   90....       MOV       DPTR,#zclSampleLight_OnOff
   \   00005B   E0           MOVX      A,@DPTR
   \   00005C   6401         XRL       A,#0x1
   \   00005E   7004         JNZ       ??zclSampleLight_LcdDisplayUpdate_8
   \   000060                ; Setup parameters for call to function HalLedSet
   \   000060   7A01         MOV       R2,#0x1
   \   000062   8002         SJMP      ??zclSampleLight_LcdDisplayUpdate_9
   \                     ??zclSampleLight_LcdDisplayUpdate_8:
   \   000064                ; Setup parameters for call to function HalLedSet
   \   000064   7A00         MOV       R2,#0x0
   \                     ??zclSampleLight_LcdDisplayUpdate_9:
   \   000066   7901         MOV       R1,#0x1
   \   000068   12....       LCALL     `??HalLedSet::?relay`; Banked call to: HalLedSet
   \   00006B   90....       MOV       DPTR,#giLightScreenMode
   \   00006E   E0           MOVX      A,@DPTR
   \   00006F   7015         JNZ       ??zclSampleLight_LcdDisplayUpdate_10
   \   000071   90....       MOV       DPTR,#zclSampleLight_OnOff
   \   000074   E0           MOVX      A,@DPTR
   \   000075   7902         MOV       R1,#0x2
   \   000077   6006         JZ        ??zclSampleLight_LcdDisplayUpdate_11
   \   000079                ; Setup parameters for call to function HalLcdWriteString
   \   000079   7A..         MOV       R2,#sLightOn & 0xff
   \   00007B   7B..         MOV       R3,#(sLightOn >> 8) & 0xff
   \   00007D   8004         SJMP      ??zclSampleLight_LcdDisplayUpdate_12
   \                     ??zclSampleLight_LcdDisplayUpdate_11:
   \   00007F                ; Setup parameters for call to function HalLcdWriteString
   \   00007F   7A..         MOV       R2,#sLightOff & 0xff
   \   000081   7B..         MOV       R3,#(sLightOff >> 8) & 0xff
   \                     ??zclSampleLight_LcdDisplayUpdate_12:
   \   000083   12....       LCALL     `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
    685          }
   \                     ??zclSampleLight_LcdDisplayUpdate_10:
   \   000086   80..         SJMP      ?Subroutine1

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    686          
    687          #if (defined HAL_BOARD_ZLIGHT) || (defined HAL_PWM)
    688          /*********************************************************************
    689           * @fn      zclSampleLight_UpdateLampLevel
    690           *
    691           * @brief   Update lamp level output with gamma compensation
    692           *
    693           * @param   level
    694           *
    695           * @return  none
    696           */
    697          void zclSampleLight_UpdateLampLevel( uint8 level )
    698          
    699          {
    700            uint16 gammaCorrectedLevel;
    701          
    702            // gamma correct the level
    703            gammaCorrectedLevel = (uint16) ( pow( ( (float)level / LEVEL_MAX ), (float)GAMMA_VALUE ) * (float)LEVEL_MAX);
    704          
    705            halTimer1SetChannelDuty(WHITE_LED, (uint16)(((uint32)gammaCorrectedLevel*PWM_FULL_DUTY_CYCLE)/LEVEL_MAX) );
    706          }
    707          #endif
    708          
    709          /*********************************************************************
    710           * @fn      zclSampleLight_DisplayLight
    711           *
    712           * @brief   Displays current state of light on LED and also on main display if supported.
    713           *
    714           * @param   none
    715           *
    716           * @return  none
    717           */
    718          static void zclSampleLight_DisplayLight( void )
    719          {
    720            // set the LED1 based on light (on or off)
    721            if ( zclSampleLight_OnOff == LIGHT_ON )
    722            {
    723              HalLedSet ( HAL_LED_1, HAL_LED_MODE_ON );
    724            }
    725            else
    726            {
    727              HalLedSet ( HAL_LED_1, HAL_LED_MODE_OFF );
    728            }
    729          
    730          #ifdef LCD_SUPPORTED
    731            if (giLightScreenMode == LIGHT_MAINMODE)
    732            {
    733          #ifdef ZCL_LEVEL_CTRL
    734              // display current light level
    735              if ( ( zclSampleLight_LevelCurrentLevel == ATTR_LEVEL_MIN_LEVEL ) &&
    736                   ( zclSampleLight_OnOff == LIGHT_OFF ) )
    737              {
    738                HalLcdWriteString( (char *)sLightOff, HAL_LCD_LINE_2 );
    739              }
    740              else if ( ( zclSampleLight_LevelCurrentLevel >= ATTR_LEVEL_MAX_LEVEL ) ||
    741                        ( zclSampleLight_LevelCurrentLevel == zclSampleLight_LevelOnLevel ) ||
    742                         ( ( zclSampleLight_LevelOnLevel == ATTR_LEVEL_ON_LEVEL_NO_EFFECT ) &&
    743                           ( zclSampleLight_LevelCurrentLevel == zclSampleLight_LevelLastLevel ) ) )
    744              {
    745                HalLcdWriteString( (char *)sLightOn, HAL_LCD_LINE_2 );
    746              }
    747              else    // "    LEVEL ###"
    748              {
    749                zclHA_uint8toa( zclSampleLight_LevelCurrentLevel, &sLightLevel[10] );
    750                HalLcdWriteString( (char *)sLightLevel, HAL_LCD_LINE_2 );
    751              }
    752          #else
    753              if ( zclSampleLight_OnOff )
    754              {
    755                HalLcdWriteString( (char *)sLightOn, HAL_LCD_LINE_2 );
    756              }
    757              else
    758              {
    759                HalLcdWriteString( (char *)sLightOff, HAL_LCD_LINE_2 );
    760              }
    761          #endif // ZCL_LEVEL_CTRL
    762            }
    763          #endif // LCD_SUPPORTED
    764          }
    765          
    766          #ifdef LCD_SUPPORTED
    767          /*********************************************************************
    768           * @fn      zclSampleLight_LcdDisplayMainMode
    769           *
    770           * @brief   Called to display the main screen on the LCD.
    771           *
    772           * @param   none
    773           *
    774           * @return  none
    775           */
    776          static void zclSampleLight_LcdDisplayMainMode( void )
    777          {
    778            // display line 1 to indicate NWK status
    779            if ( zclSampleLight_NwkState == DEV_ZB_COORD )
    780            {
    781              zclHA_LcdStatusLine1( ZCL_HA_STATUSLINE_ZC );
    782            }
    783            else if ( zclSampleLight_NwkState == DEV_ROUTER )
    784            {
    785              zclHA_LcdStatusLine1( ZCL_HA_STATUSLINE_ZR );
    786            }
    787            else if ( zclSampleLight_NwkState == DEV_END_DEVICE )
    788            {
    789              zclHA_LcdStatusLine1( ZCL_HA_STATUSLINE_ZED );
    790            }
    791          
    792            // end of line 3 displays permit join status (*)
    793            if ( gPermitDuration )
    794            {
    795              sSwHelp[15] = '*';
    796            }
    797            else
    798            {
    799              sSwHelp[15] = ' ';
    800            }
    801            HalLcdWriteString( (char *)sSwHelp, HAL_LCD_LINE_3 );
    802          }
    803          
    804          /*********************************************************************
    805           * @fn      zclSampleLight_LcdDisplayHelpMode
    806           *
    807           * @brief   Called to display the SW options on the LCD.
    808           *
    809           * @param   none
    810           *
    811           * @return  none
    812           */
    813          static void zclSampleLight_LcdDisplayHelpMode( void )
    814          {
    815            HalLcdWriteString( (char *)sSwLight, HAL_LCD_LINE_1 );
    816            HalLcdWriteString( (char *)sSwEZMode, HAL_LCD_LINE_2 );
    817            HalLcdWriteString( (char *)sSwHelp, HAL_LCD_LINE_3 );
    818          }
    819          #endif  // LCD_SUPPORTED
    820          
    821          /*********************************************************************
    822           * @fn      zclSampleLight_ProcessIdentifyTimeChange
    823           *
    824           * @brief   Called to process any change to the IdentifyTime attribute.
    825           *
    826           * @param   none
    827           *
    828           * @return  none
    829           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    830          static void zclSampleLight_ProcessIdentifyTimeChange( void )
   \                     zclSampleLight_ProcessIdentifyTimeChange:
    831          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    832            if ( zclSampleLight_IdentifyTime > 0 )
   \   000004   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000007   E8           MOV       A,R0
   \   000008   49           ORL       A,R1
   \   000009   6026         JZ        ??zclSampleLight_ProcessIdentifyTimeChange_0
    833            {
    834              osal_start_timerEx( zclSampleLight_TaskID, SAMPLELIGHT_IDENTIFY_TIMEOUT_EVT, 1000 );
   \   00000B                ; Setup parameters for call to function osal_start_timerEx
   \   00000B   90....       MOV       DPTR,#__Constant_3e8
   \   00000E   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   000011   7A01         MOV       R2,#0x1
   \   000013   7B00         MOV       R3,#0x0
   \   000015   90....       MOV       DPTR,#zclSampleLight_TaskID
   \   000018   E0           MOVX      A,@DPTR
   \   000019   F9           MOV       R1,A
   \   00001A   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   00001D   7404         MOV       A,#0x4
   \   00001F   12....       LCALL     ?DEALLOC_XSTACK8
    835              HalLedBlink ( HAL_LED_4, 0xFF, HAL_LED_DEFAULT_DUTY_CYCLE, HAL_LED_DEFAULT_FLASH_TIME );
   \   000022                ; Setup parameters for call to function HalLedBlink
   \   000022   7CE8         MOV       R4,#-0x18
   \   000024   7D03         MOV       R5,#0x3
   \   000026   7B05         MOV       R3,#0x5
   \   000028   7AFF         MOV       R2,#-0x1
   \   00002A   7908         MOV       R1,#0x8
   \   00002C   12....       LCALL     `??HalLedBlink::?relay`; Banked call to: HalLedBlink
   \   00002F   800C         SJMP      ??zclSampleLight_ProcessIdentifyTimeChange_1
    836            }
    837            else
    838            {
    839          #ifdef ZCL_EZMODE
    840              if ( zclSampleLight_IdentifyCommissionState & EZMODE_COMMISSION_OPERATIONAL )
    841              {
    842                HalLedSet ( HAL_LED_4, HAL_LED_MODE_ON );
    843              }
    844              else
    845              {
    846                HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
    847              }
    848          #endif
    849          
    850              osal_stop_timerEx( zclSampleLight_TaskID, SAMPLELIGHT_IDENTIFY_TIMEOUT_EVT );
   \                     ??zclSampleLight_ProcessIdentifyTimeChange_0:
   \   000031                ; Setup parameters for call to function osal_stop_timerEx
   \   000031   7A01         MOV       R2,#0x1
   \   000033   7B00         MOV       R3,#0x0
   \   000035   90....       MOV       DPTR,#zclSampleLight_TaskID
   \   000038   E0           MOVX      A,@DPTR
   \   000039   F9           MOV       R1,A
   \   00003A   12....       LCALL     `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
    851            }
    852          }
   \                     ??zclSampleLight_ProcessIdentifyTimeChange_1:
   \   00003D   80..         SJMP      ?Subroutine1
    853          
    854          /*********************************************************************
    855           * @fn      zclSampleLight_BasicResetCB
    856           *
    857           * @brief   Callback from the ZCL General Cluster Library
    858           *          to set all the Basic Cluster attributes to default values.
    859           *
    860           * @param   none
    861           *
    862           * @return  none
    863           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    864          static void zclSampleLight_BasicResetCB( void )
   \                     zclSampleLight_BasicResetCB:
    865          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 5
   \   000004   74FB         MOV       A,#-0x5
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    866            NLME_LeaveReq_t leaveReq;
    867            // Set every field to 0
    868            osal_memset( &leaveReq, 0, sizeof( NLME_LeaveReq_t ) );
   \   000009                ; Setup parameters for call to function osal_memset
   \   000009   7C05         MOV       R4,#0x5
   \   00000B   7D00         MOV       R5,#0x0
   \   00000D   7900         MOV       R1,#0x0
   \   00000F   AA..         MOV       R2,?XSP + 0
   \   000011   AB..         MOV       R3,?XSP + 1
   \   000013   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    869          
    870            // This will enable the device to rejoin the network after reset.
    871            leaveReq.rejoin = TRUE;
   \   000016   7403         MOV       A,#0x3
   \   000018   12....       LCALL     ?XSTACK_DISP0_8
   \   00001B   7401         MOV       A,#0x1
   \   00001D   F0           MOVX      @DPTR,A
    872          
    873            // Set the NV startup option to force a "new" join.
    874            zgWriteStartupOptions( ZG_STARTUP_SET, ZCD_STARTOPT_DEFAULT_NETWORK_STATE );
   \   00001E                ; Setup parameters for call to function zgWriteStartupOptions
   \   00001E   7A02         MOV       R2,#0x2
   \   000020   79FF         MOV       R1,#-0x1
   \   000022   12....       LCALL     `??zgWriteStartupOptions::?relay`; Banked call to: zgWriteStartupOptions
    875          
    876            // Leave the network, and reset afterwards
    877            if ( NLME_LeaveReq( &leaveReq ) != ZSuccess )
   \   000025                ; Setup parameters for call to function NLME_LeaveReq
   \   000025   AA..         MOV       R2,?XSP + 0
   \   000027   AB..         MOV       R3,?XSP + 1
   \   000029   12....       LCALL     `??NLME_LeaveReq::?relay`; Banked call to: NLME_LeaveReq
   \   00002C   E9           MOV       A,R1
   \   00002D   6005         JZ        ??zclSampleLight_BasicResetCB_0
    878            {
    879              // Couldn't send out leave; prepare to reset anyway
    880              ZDApp_LeaveReset( FALSE );
   \   00002F                ; Setup parameters for call to function ZDApp_LeaveReset
   \   00002F   7900         MOV       R1,#0x0
   \   000031   12....       LCALL     `??ZDApp_LeaveReset::?relay`; Banked call to: ZDApp_LeaveReset
    881            }
    882          }
   \                     ??zclSampleLight_BasicResetCB_0:
   \   000034   7405         MOV       A,#0x5
   \   000036   12....       LCALL     ?DEALLOC_XSTACK8
   \   000039                REQUIRE ?Subroutine1
   \   000039                ; // Fall through to label ?Subroutine1
    883          
    884          /*********************************************************************
    885           * @fn      zclSampleLight_IdentifyCB
    886           *
    887           * @brief   Callback from the ZCL General Cluster Library when
    888           *          it received an Identity Command for this application.
    889           *
    890           * @param   srcAddr - source address and endpoint of the response message
    891           * @param   identifyTime - the number of seconds to identify yourself
    892           *
    893           * @return  none
    894           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    895          static void zclSampleLight_IdentifyCB( zclIdentify_t *pCmd )
   \                     zclSampleLight_IdentifyCB:
    896          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    897            zclSampleLight_IdentifyTime = pCmd->identifyTime;
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   12....       LCALL     ??Subroutine4_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   00000D   90....       MOV       DPTR,#zclSampleLight_IdentifyTime
   \   000010   E8           MOV       A,R0
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   E9           MOV       A,R1
   \   000014   F0           MOVX      @DPTR,A
    898            zclSampleLight_ProcessIdentifyTimeChange();
   \   000015                ; Setup parameters for call to function zclSampleLight_ProcessIdentifyTimeChange
   \   000015   12....       LCALL     `??zclSampleLight_ProcessIdentifyTimeChange::?re`; Banked call to: zclSampleLight_ProcessIdentifyTimeChange
    899          }
   \   000018   80..         SJMP      ?Subroutine1
    900          
    901          /*********************************************************************
    902           * @fn      zclSampleLight_IdentifyQueryRspCB
    903           *
    904           * @brief   Callback from the ZCL General Cluster Library when
    905           *          it received an Identity Query Response Command for this application.
    906           *
    907           * @param   srcAddr - requestor's address
    908           * @param   timeout - number of seconds to identify yourself (valid for query response)
    909           *
    910           * @return  none
    911           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    912          static void zclSampleLight_IdentifyQueryRspCB(  zclIdentifyQueryRsp_t *pRsp )
   \                     zclSampleLight_IdentifyQueryRspCB:
    913          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    914            (void)pRsp;
    915          #ifdef ZCL_EZMODE
    916            {
    917              zclEZMode_ActionData_t data;
    918              data.pIdentifyQueryRsp = pRsp;
    919              zcl_EZModeAction ( EZMODE_ACTION_IDENTIFY_QUERY_RSP, &data );
    920            }
    921          #endif
    922          }
   \   000000   02....       LJMP      ?BRET
    923          
    924          /*********************************************************************
    925           * @fn      zclSampleLight_OnOffCB
    926           *
    927           * @brief   Callback from the ZCL General Cluster Library when
    928           *          it received an On/Off Command for this application.
    929           *
    930           * @param   cmd - COMMAND_ON, COMMAND_OFF or COMMAND_TOGGLE
    931           *
    932           * @return  none
    933           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    934          static void zclSampleLight_OnOffCB( uint8 cmd )
   \                     zclSampleLight_OnOffCB:
    935          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
    936            afIncomingMSGPacket_t *pPtr = zcl_getRawAFMsg();
   \   000007                ; Setup parameters for call to function zcl_getRawAFMsg
   \   000007   12....       LCALL     `??zcl_getRawAFMsg::?relay`; Banked call to: zcl_getRawAFMsg
   \   00000A   8A82         MOV       DPL,R2
   \   00000C   8B83         MOV       DPH,R3
    937          
    938            zclSampleLight_DstAddr.addr.shortAddr = pPtr->srcAddr.addr.shortAddr;
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   12....       LCALL     ??Subroutine4_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000017   90....       MOV       DPTR,#zclSampleLight_DstAddr
   \   00001A   E8           MOV       A,R0
   \   00001B   F0           MOVX      @DPTR,A
   \   00001C   A3           INC       DPTR
   \   00001D   E9           MOV       A,R1
   \   00001E   F0           MOVX      @DPTR,A
    939          
    940          
    941            // Turn on the light
    942            if ( cmd == COMMAND_ON )
   \   00001F   7401         MOV       A,#0x1
   \   000021   6E           XRL       A,R6
   \   000022   600E         JZ        ??zclSampleLight_OnOffCB_0
    943            {
    944              zclSampleLight_OnOff = LIGHT_ON;
    945            }
    946            // Turn off the light
    947            else if ( cmd == COMMAND_OFF )
   \   000024   EE           MOV       A,R6
   \   000025   6012         JZ        ??zclSampleLight_OnOffCB_1
    948            {
    949              zclSampleLight_OnOff = LIGHT_OFF;
    950            }
    951            // Toggle the light
    952            else if ( cmd == COMMAND_TOGGLE )
   \   000027   7402         MOV       A,#0x2
   \   000029   6E           XRL       A,R6
   \   00002A   7012         JNZ       ??zclSampleLight_OnOffCB_2
    953            {
    954              if ( zclSampleLight_OnOff == LIGHT_OFF )
   \   00002C   90....       MOV       DPTR,#zclSampleLight_OnOff
   \   00002F   E0           MOVX      A,@DPTR
   \   000030   7007         JNZ       ??zclSampleLight_OnOffCB_1
    955              {
    956                zclSampleLight_OnOff = LIGHT_ON;
   \                     ??zclSampleLight_OnOffCB_0:
   \   000032   90....       MOV       DPTR,#zclSampleLight_OnOff
   \   000035   7401         MOV       A,#0x1
   \   000037   8004         SJMP      ??zclSampleLight_OnOffCB_3
    957              }
    958              else
    959              {
    960                zclSampleLight_OnOff = LIGHT_OFF;
   \                     ??zclSampleLight_OnOffCB_1:
   \   000039   90....       MOV       DPTR,#zclSampleLight_OnOff
   \   00003C   E4           CLR       A
   \                     ??zclSampleLight_OnOffCB_3:
   \   00003D   F0           MOVX      @DPTR,A
    961              }
    962            }
    963          
    964          #if ZCL_LEVEL_CTRL
    965            zclSampleLight_DefaultMove( );
    966          #endif
    967          
    968            // update the display
    969            zclSampleLight_LcdDisplayUpdate( );
   \                     ??zclSampleLight_OnOffCB_2:
   \   00003E                ; Setup parameters for call to function zclSampleLight_LcdDisplayUpdate
   \   00003E   12....       LCALL     `??zclSampleLight_LcdDisplayUpdate::?relay`; Banked call to: zclSampleLight_LcdDisplayUpdate
    970          }
   \   000041   02....       LJMP      ?Subroutine0 & 0xFFFF

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for bindingInClusters>`:
   \   000000   0600         DW 6

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for sampleLight_TestEp>`:
   \   000000   08           DB 8
   \   000001   ....         DW zclSampleLight_TaskID
   \   000003   0000         DW 0H
   \   000005   00           DB 0

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zclSampleLight_NwkState>`:
   \   000000   01           DB 1

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for sSwHelp>`:
   \   000000   5357353A     DB "SW5: Help       "
   \            2048656C
   \            70202020
   \            20202020
   \            00      

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zclSampleLight_CmdCallbacks>`:
   \   000000   ....         DW `??zclSampleLight_BasicResetCB::?relay`
   \   000002   ....         DW `??zclSampleLight_IdentifyCB::?relay`
   \   000004   0000         DW 0H
   \   000006   ....         DW `??zclSampleLight_IdentifyQueryRspCB::?relay`
   \   000008   ....         DW `??zclSampleLight_OnOffCB::?relay`
   \   00000A   0000         DW 0H
   \   00000C   0000         DW 0H
   \   00000E   0000         DW 0H
   \   000010   0000         DW 0H
   \   000012   0000         DW 0H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "UartInit OK\\n">`:
   \   000000   55617274     DB "UartInit OK\012"
   \            496E6974
   \            204F4B0A
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e8:
   \   000000   E8030000     DD 1000
    971          
    972          #ifdef ZCL_LEVEL_CTRL
    973          /*********************************************************************
    974           * @fn      zclSampleLight_TimeRateHelper
    975           *
    976           * @brief   Calculate time based on rate, and startup level state machine
    977           *
    978           * @param   newLevel - new level for current level
    979           *
    980           * @return  diff (directly), zclSampleLight_CurrentLevel32 and zclSampleLight_NewLevel, zclSampleLight_NewLevelUp
    981           */
    982          static uint32 zclSampleLight_TimeRateHelper( uint8 newLevel )
    983          {
    984            uint32 diff;
    985            uint32 newLevel32;
    986          
    987            // remember current and new level
    988            zclSampleLight_NewLevel = newLevel;
    989            zclSampleLight_CurrentLevel32 = (uint32)1000 * zclSampleLight_LevelCurrentLevel;
    990          
    991            // calculate diff
    992            newLevel32 = (uint32)1000 * newLevel;
    993            if ( zclSampleLight_LevelCurrentLevel > newLevel )
    994            {
    995              diff = zclSampleLight_CurrentLevel32 - newLevel32;
    996              zclSampleLight_NewLevelUp = FALSE;  // moving down
    997            }
    998            else
    999            {
   1000              diff = newLevel32 - zclSampleLight_CurrentLevel32;
   1001              zclSampleLight_NewLevelUp = TRUE;   // moving up
   1002            }
   1003          
   1004            return ( diff );
   1005          }
   1006          
   1007          /*********************************************************************
   1008           * @fn      zclSampleLight_MoveBasedOnRate
   1009           *
   1010           * @brief   Calculate time based on rate, and startup level state machine
   1011           *
   1012           * @param   newLevel - new level for current level
   1013           * @param   rate16   - fixed point rate (e.g. 16.123)
   1014           *
   1015           * @return  none
   1016           */
   1017          static void zclSampleLight_MoveBasedOnRate( uint8 newLevel, uint32 rate )
   1018          {
   1019            uint32 diff;
   1020          
   1021            // determine how much time (in 10ths of seconds) based on the difference and rate
   1022            zclSampleLight_Rate32 = rate;
   1023            diff = zclSampleLight_TimeRateHelper( newLevel );
   1024            zclSampleLight_LevelRemainingTime = diff / rate;
   1025            if ( !zclSampleLight_LevelRemainingTime )
   1026            {
   1027              zclSampleLight_LevelRemainingTime = 1;
   1028            }
   1029          
   1030            osal_start_timerEx( zclSampleLight_TaskID, SAMPLELIGHT_LEVEL_CTRL_EVT, 100 );
   1031          }
   1032          
   1033          /*********************************************************************
   1034           * @fn      zclSampleLight_MoveBasedOnTime
   1035           *
   1036           * @brief   Calculate rate based on time, and startup level state machine
   1037           *
   1038           * @param   newLevel  - new level for current level
   1039           * @param   time      - in 10ths of seconds
   1040           *
   1041           * @return  none
   1042           */
   1043          static void zclSampleLight_MoveBasedOnTime( uint8 newLevel, uint16 time )
   1044          {
   1045            uint16 diff;
   1046          
   1047            // determine rate (in units) based on difference and time
   1048            diff = zclSampleLight_TimeRateHelper( newLevel );
   1049            zclSampleLight_LevelRemainingTime = zclSampleLight_GetTime( newLevel, time );
   1050            zclSampleLight_Rate32 = diff / time;
   1051          
   1052            osal_start_timerEx( zclSampleLight_TaskID, SAMPLELIGHT_LEVEL_CTRL_EVT, 100 );
   1053          }
   1054          
   1055          /*********************************************************************
   1056           * @fn      zclSampleLight_GetTime
   1057           *
   1058           * @brief   Determine amount of time that MoveXXX will take to complete.
   1059           *
   1060           * @param   level = new level to move to
   1061           *          time  = 0xffff=default, or 0x0000-n amount of time in tenths of seconds.
   1062           *
   1063           * @return  none
   1064           */
   1065          static uint16 zclSampleLight_GetTime( uint8 level, uint16 time )
   1066          {
   1067            // there is a hiearchy of the amount of time to use for transistioning
   1068            // check each one in turn. If none of defaults are set, then use fastest
   1069            // time possible.
   1070            if ( time == 0xFFFF )
   1071            {
   1072              // use On or Off Transition Time if set (not 0xffff)
   1073              if ( zclSampleLight_OnOff == LIGHT_ON )
   1074              {
   1075                time = zclSampleLight_LevelOffTransitionTime;
   1076              }
   1077              else
   1078              {
   1079                time = zclSampleLight_LevelOnTransitionTime;
   1080              }
   1081          
   1082              // else use OnOffTransitionTime if set (not 0xffff)
   1083              if ( time == 0xFFFF )
   1084              {
   1085                time = zclSampleLight_LevelOnOffTransitionTime;
   1086              }
   1087          
   1088              // else as fast as possible
   1089              if ( time == 0xFFFF )
   1090              {
   1091                time = 1;
   1092              }
   1093            }
   1094          
   1095            if ( !time )
   1096            {
   1097              time = 1; // as fast as possible
   1098            }
   1099          
   1100            return ( time );
   1101          }
   1102          
   1103          /*********************************************************************
   1104           * @fn      zclSampleLight_DefaultMove
   1105           *
   1106           * @brief   We were turned on/off. Use default time to move to on or off.
   1107           *
   1108           * @param   zclSampleLight_OnOff - must be set prior to calling this function.
   1109           *
   1110           * @return  none
   1111           */
   1112          static void zclSampleLight_DefaultMove( void )
   1113          {
   1114            uint8  newLevel;
   1115            uint32 rate;      // fixed point decimal (3 places, eg. 16.345)
   1116            uint16 time;
   1117          
   1118            // if moving to on position, move to on level
   1119            if ( zclSampleLight_OnOff )
   1120            {
   1121              if ( zclSampleLight_LevelOnLevel == ATTR_LEVEL_ON_LEVEL_NO_EFFECT )
   1122              {
   1123                // The last Level (before going OFF) should be used)
   1124                newLevel = zclSampleLight_LevelLastLevel;
   1125              }
   1126              else
   1127              {
   1128                newLevel = zclSampleLight_LevelOnLevel;
   1129              }
   1130          
   1131              time = zclSampleLight_LevelOnTransitionTime;
   1132            }
   1133            else
   1134            {
   1135              newLevel = ATTR_LEVEL_MIN_LEVEL;
   1136          
   1137              if ( zclSampleLight_LevelOnLevel == ATTR_LEVEL_ON_LEVEL_NO_EFFECT )
   1138              {
   1139                // Save the current Level before going OFF to use it when the light turns ON
   1140                // it should be back to this level
   1141                zclSampleLight_LevelLastLevel = zclSampleLight_LevelCurrentLevel;
   1142              }
   1143          
   1144              time = zclSampleLight_LevelOffTransitionTime;
   1145            }
   1146          
   1147            // else use OnOffTransitionTime if set (not 0xffff)
   1148            if ( time == 0xFFFF )
   1149            {
   1150              time = zclSampleLight_LevelOnOffTransitionTime;
   1151            }
   1152          
   1153            // else as fast as possible
   1154            if ( time == 0xFFFF )
   1155            {
   1156              time = 1;
   1157            }
   1158          
   1159            // calculate rate based on time (int 10ths) for full transition (1-254)
   1160            rate = 255000 / time;    // units per tick, fixed point, 3 decimal places (e.g. 8500 = 8.5 units per tick)
   1161          
   1162            // start up state machine.
   1163            zclSampleLight_WithOnOff = TRUE;
   1164            zclSampleLight_MoveBasedOnRate( newLevel, rate );
   1165          }
   1166          
   1167          /*********************************************************************
   1168           * @fn      zclSampleLight_AdjustLightLevel
   1169           *
   1170           * @brief   Called each 10th of a second while state machine running
   1171           *
   1172           * @param   none
   1173           *
   1174           * @return  none
   1175           */
   1176          static void zclSampleLight_AdjustLightLevel( void )
   1177          {
   1178            // one tick (10th of a second) less
   1179            if ( zclSampleLight_LevelRemainingTime )
   1180            {
   1181              --zclSampleLight_LevelRemainingTime;
   1182            }
   1183          
   1184            // no time left, done
   1185            if ( zclSampleLight_LevelRemainingTime == 0)
   1186            {
   1187              zclSampleLight_LevelCurrentLevel = zclSampleLight_NewLevel;
   1188            }
   1189          
   1190            // still time left, keep increment/decrementing
   1191            else
   1192            {
   1193              if ( zclSampleLight_NewLevelUp )
   1194              {
   1195                zclSampleLight_CurrentLevel32 += zclSampleLight_Rate32;
   1196              }
   1197              else
   1198              {
   1199                zclSampleLight_CurrentLevel32 -= zclSampleLight_Rate32;
   1200              }
   1201              zclSampleLight_LevelCurrentLevel = (uint8)( zclSampleLight_CurrentLevel32 / 1000 );
   1202            }
   1203          
   1204          #if (defined HAL_BOARD_ZLIGHT) || (defined HAL_PWM)
   1205            zclSampleLight_UpdateLampLevel(zclSampleLight_LevelCurrentLevel);
   1206          #endif
   1207          
   1208            // also affect on/off
   1209            if ( zclSampleLight_WithOnOff )
   1210            {
   1211              if ( zclSampleLight_LevelCurrentLevel > ATTR_LEVEL_MIN_LEVEL )
   1212              {
   1213                zclSampleLight_OnOff = LIGHT_ON;
   1214          #if (defined HAL_BOARD_ZLIGHT) || (defined HAL_PWM)
   1215                ENABLE_LAMP;
   1216          #endif
   1217              }
   1218              else
   1219              {
   1220                zclSampleLight_OnOff = LIGHT_OFF;
   1221          #if (defined HAL_BOARD_ZLIGHT) || (defined HAL_PWM)
   1222                DISABLE_LAMP;
   1223          #endif
   1224              }
   1225            }
   1226          
   1227            // display light level as we go
   1228            zclSampleLight_DisplayLight( );
   1229          
   1230            // keep ticking away
   1231            if ( zclSampleLight_LevelRemainingTime )
   1232            {
   1233              osal_start_timerEx( zclSampleLight_TaskID, SAMPLELIGHT_LEVEL_CTRL_EVT, 100 );
   1234            }
   1235          }
   1236          
   1237          /*********************************************************************
   1238           * @fn      zclSampleLight_LevelControlMoveToLevelCB
   1239           *
   1240           * @brief   Callback from the ZCL General Cluster Library when
   1241           *          it received a LevelControlMoveToLevel Command for this application.
   1242           *
   1243           * @param   pCmd - ZigBee command parameters
   1244           *
   1245           * @return  none
   1246           */
   1247          static void zclSampleLight_LevelControlMoveToLevelCB( zclLCMoveToLevel_t *pCmd )
   1248          {
   1249            zclSampleLight_WithOnOff = pCmd->withOnOff;
   1250            zclSampleLight_MoveBasedOnTime( pCmd->level, pCmd->transitionTime );
   1251          }
   1252          
   1253          /*********************************************************************
   1254           * @fn      zclSampleLight_LevelControlMoveCB
   1255           *
   1256           * @brief   Callback from the ZCL General Cluster Library when
   1257           *          it received a LevelControlMove Command for this application.
   1258           *
   1259           * @param   pCmd - ZigBee command parameters
   1260           *
   1261           * @return  none
   1262           */
   1263          static void zclSampleLight_LevelControlMoveCB( zclLCMove_t *pCmd )
   1264          {
   1265            uint8 newLevel;
   1266            uint32 rate;
   1267          
   1268            // convert rate from units per second to units per tick (10ths of seconds)
   1269            // and move at that right up or down
   1270            zclSampleLight_WithOnOff = pCmd->withOnOff;
   1271          
   1272            if ( pCmd->moveMode == LEVEL_MOVE_UP )
   1273            {
   1274              newLevel = ATTR_LEVEL_MAX_LEVEL;  // fully on
   1275            }
   1276            else
   1277            {
   1278              newLevel = ATTR_LEVEL_MIN_LEVEL; // fully off
   1279            }
   1280          
   1281            rate = (uint32)100 * pCmd->rate;
   1282            zclSampleLight_MoveBasedOnRate( newLevel, rate );
   1283          }
   1284          
   1285          /*********************************************************************
   1286           * @fn      zclSampleLight_LevelControlStepCB
   1287           *
   1288           * @brief   Callback from the ZCL General Cluster Library when
   1289           *          it received an On/Off Command for this application.
   1290           *
   1291           * @param   pCmd - ZigBee command parameters
   1292           *
   1293           * @return  none
   1294           */
   1295          static void zclSampleLight_LevelControlStepCB( zclLCStep_t *pCmd )
   1296          {
   1297            uint8 newLevel;
   1298          
   1299            // determine new level, but don't exceed boundaries
   1300            if ( pCmd->stepMode == LEVEL_MOVE_UP )
   1301            {
   1302              if ( (uint16)zclSampleLight_LevelCurrentLevel + pCmd->amount > ATTR_LEVEL_MAX_LEVEL )
   1303              {
   1304                newLevel = ATTR_LEVEL_MAX_LEVEL;
   1305              }
   1306              else
   1307              {
   1308                newLevel = zclSampleLight_LevelCurrentLevel + pCmd->amount;
   1309              }
   1310            }
   1311            else
   1312            {
   1313              if ( pCmd->amount >= zclSampleLight_LevelCurrentLevel )
   1314              {
   1315                newLevel = ATTR_LEVEL_MIN_LEVEL;
   1316              }
   1317              else
   1318              {
   1319                newLevel = zclSampleLight_LevelCurrentLevel - pCmd->amount;
   1320              }
   1321            }
   1322          
   1323            // move to the new level
   1324            zclSampleLight_WithOnOff = pCmd->withOnOff;
   1325            zclSampleLight_MoveBasedOnTime( newLevel, pCmd->transitionTime );
   1326          }
   1327          
   1328          /*********************************************************************
   1329           * @fn      zclSampleLight_LevelControlStopCB
   1330           *
   1331           * @brief   Callback from the ZCL General Cluster Library when
   1332           *          it received an Level Control Stop Command for this application.
   1333           *
   1334           * @param   pCmd - ZigBee command parameters
   1335           *
   1336           * @return  none
   1337           */
   1338          static void zclSampleLight_LevelControlStopCB( void )
   1339          {
   1340            // stop immediately
   1341            osal_stop_timerEx( zclSampleLight_TaskID, SAMPLELIGHT_LEVEL_CTRL_EVT );
   1342            zclSampleLight_LevelRemainingTime = 0;
   1343          }
   1344          #endif
   1345          
   1346          /******************************************************************************
   1347           *
   1348           *  Functions for processing ZCL Foundation incoming Command/Response messages
   1349           *
   1350           *****************************************************************************/
   1351          
   1352          /*********************************************************************
   1353           * @fn      zclSampleLight_ProcessIncomingMsg
   1354           *
   1355           * @brief   Process ZCL Foundation incoming message
   1356           *
   1357           * @param   pInMsg - pointer to the received message
   1358           *
   1359           * @return  none
   1360           */
   1361          static void zclSampleLight_ProcessIncomingMsg( zclIncomingMsg_t *pInMsg )
   1362          {
   1363            switch ( pInMsg->zclHdr.commandID )
   1364            {
   1365          #ifdef ZCL_READ
   1366              case ZCL_CMD_READ_RSP:
   1367                zclSampleLight_ProcessInReadRspCmd( pInMsg );
   1368                break;
   1369          #endif
   1370          #ifdef ZCL_WRITE
   1371              case ZCL_CMD_WRITE_RSP:
   1372                zclSampleLight_ProcessInWriteRspCmd( pInMsg );
   1373                break;
   1374          #endif
   1375          #ifdef ZCL_REPORT
   1376              // Attribute Reporting implementation should be added here
   1377              case ZCL_CMD_CONFIG_REPORT:
   1378                // zclSampleLight_ProcessInConfigReportCmd( pInMsg );
   1379                break;
   1380          
   1381              case ZCL_CMD_CONFIG_REPORT_RSP:
   1382                // zclSampleLight_ProcessInConfigReportRspCmd( pInMsg );
   1383                break;
   1384          
   1385              case ZCL_CMD_READ_REPORT_CFG:
   1386                // zclSampleLight_ProcessInReadReportCfgCmd( pInMsg );
   1387                break;
   1388          
   1389              case ZCL_CMD_READ_REPORT_CFG_RSP:
   1390                // zclSampleLight_ProcessInReadReportCfgRspCmd( pInMsg );
   1391                break;
   1392          
   1393              case ZCL_CMD_REPORT:
   1394                // zclSampleLight_ProcessInReportCmd( pInMsg );
   1395                break;
   1396          #endif
   1397              case ZCL_CMD_DEFAULT_RSP:
   1398                zclSampleLight_ProcessInDefaultRspCmd( pInMsg );
   1399                break;
   1400          #ifdef ZCL_DISCOVER
   1401              case ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP:
   1402                zclSampleLight_ProcessInDiscCmdsRspCmd( pInMsg );
   1403                break;
   1404          
   1405              case ZCL_CMD_DISCOVER_CMDS_GEN_RSP:
   1406                zclSampleLight_ProcessInDiscCmdsRspCmd( pInMsg );
   1407                break;
   1408          
   1409              case ZCL_CMD_DISCOVER_ATTRS_RSP:
   1410                zclSampleLight_ProcessInDiscAttrsRspCmd( pInMsg );
   1411                break;
   1412          
   1413              case ZCL_CMD_DISCOVER_ATTRS_EXT_RSP:
   1414                zclSampleLight_ProcessInDiscAttrsExtRspCmd( pInMsg );
   1415                break;
   1416          #endif
   1417              default:
   1418                break;
   1419            }
   1420          
   1421            if ( pInMsg->attrCmd )
   1422              osal_mem_free( pInMsg->attrCmd );
   1423          }
   1424          
   1425          #ifdef ZCL_READ
   1426          /*********************************************************************
   1427           * @fn      zclSampleLight_ProcessInReadRspCmd
   1428           *
   1429           * @brief   Process the "Profile" Read Response Command
   1430           *
   1431           * @param   pInMsg - incoming message to process
   1432           *
   1433           * @return  none
   1434           */
   1435          static uint8 zclSampleLight_ProcessInReadRspCmd( zclIncomingMsg_t *pInMsg )
   1436          {
   1437            zclReadRspCmd_t *readRspCmd;
   1438            uint8 i;
   1439          
   1440            readRspCmd = (zclReadRspCmd_t *)pInMsg->attrCmd;
   1441            for (i = 0; i < readRspCmd->numAttr; i++)
   1442            {
   1443              // Notify the originator of the results of the original read attributes
   1444              // attempt and, for each successfull request, the value of the requested
   1445              // attribute
   1446            }
   1447          
   1448            return ( TRUE );
   1449          }
   1450          #endif // ZCL_READ
   1451          
   1452          #ifdef ZCL_WRITE
   1453          /*********************************************************************
   1454           * @fn      zclSampleLight_ProcessInWriteRspCmd
   1455           *
   1456           * @brief   Process the "Profile" Write Response Command
   1457           *
   1458           * @param   pInMsg - incoming message to process
   1459           *
   1460           * @return  none
   1461           */
   1462          static uint8 zclSampleLight_ProcessInWriteRspCmd( zclIncomingMsg_t *pInMsg )
   1463          {
   1464            zclWriteRspCmd_t *writeRspCmd;
   1465            uint8 i;
   1466          
   1467            writeRspCmd = (zclWriteRspCmd_t *)pInMsg->attrCmd;
   1468            for ( i = 0; i < writeRspCmd->numAttr; i++ )
   1469            {
   1470              // Notify the device of the results of the its original write attributes
   1471              // command.
   1472            }
   1473          
   1474            return ( TRUE );
   1475          }
   1476          #endif // ZCL_WRITE
   1477          
   1478          /*********************************************************************
   1479           * @fn      zclSampleLight_ProcessInDefaultRspCmd
   1480           *
   1481           * @brief   Process the "Profile" Default Response Command
   1482           *
   1483           * @param   pInMsg - incoming message to process
   1484           *
   1485           * @return  none
   1486           */
   1487          static uint8 zclSampleLight_ProcessInDefaultRspCmd( zclIncomingMsg_t *pInMsg )
   1488          {
   1489            // zclDefaultRspCmd_t *defaultRspCmd = (zclDefaultRspCmd_t *)pInMsg->attrCmd;
   1490          
   1491            // Device is notified of the Default Response command.
   1492            (void)pInMsg;
   1493          
   1494            return ( TRUE );
   1495          }
   1496          
   1497          #ifdef ZCL_DISCOVER
   1498          /*********************************************************************
   1499           * @fn      zclSampleLight_ProcessInDiscCmdsRspCmd
   1500           *
   1501           * @brief   Process the Discover Commands Response Command
   1502           *
   1503           * @param   pInMsg - incoming message to process
   1504           *
   1505           * @return  none
   1506           */
   1507          static uint8 zclSampleLight_ProcessInDiscCmdsRspCmd( zclIncomingMsg_t *pInMsg )
   1508          {
   1509            zclDiscoverCmdsCmdRsp_t *discoverRspCmd;
   1510            uint8 i;
   1511          
   1512            discoverRspCmd = (zclDiscoverCmdsCmdRsp_t *)pInMsg->attrCmd;
   1513            for ( i = 0; i < discoverRspCmd->numCmd; i++ )
   1514            {
   1515              // Device is notified of the result of its attribute discovery command.
   1516            }
   1517          
   1518            return ( TRUE );
   1519          }
   1520          
   1521          /*********************************************************************
   1522           * @fn      zclSampleLight_ProcessInDiscAttrsRspCmd
   1523           *
   1524           * @brief   Process the "Profile" Discover Attributes Response Command
   1525           *
   1526           * @param   pInMsg - incoming message to process
   1527           *
   1528           * @return  none
   1529           */
   1530          static uint8 zclSampleLight_ProcessInDiscAttrsRspCmd( zclIncomingMsg_t *pInMsg )
   1531          {
   1532            zclDiscoverAttrsRspCmd_t *discoverRspCmd;
   1533            uint8 i;
   1534          
   1535            discoverRspCmd = (zclDiscoverAttrsRspCmd_t *)pInMsg->attrCmd;
   1536            for ( i = 0; i < discoverRspCmd->numAttr; i++ )
   1537            {
   1538              // Device is notified of the result of its attribute discovery command.
   1539            }
   1540          
   1541            return ( TRUE );
   1542          }
   1543          
   1544          /*********************************************************************
   1545           * @fn      zclSampleLight_ProcessInDiscAttrsExtRspCmd
   1546           *
   1547           * @brief   Process the "Profile" Discover Attributes Extended Response Command
   1548           *
   1549           * @param   pInMsg - incoming message to process
   1550           *
   1551           * @return  none
   1552           */
   1553          static uint8 zclSampleLight_ProcessInDiscAttrsExtRspCmd( zclIncomingMsg_t *pInMsg )
   1554          {
   1555            zclDiscoverAttrsExtRsp_t *discoverRspCmd;
   1556            uint8 i;
   1557          
   1558            discoverRspCmd = (zclDiscoverAttrsExtRsp_t *)pInMsg->attrCmd;
   1559            for ( i = 0; i < discoverRspCmd->numAttr; i++ )
   1560            {
   1561              // Device is notified of the result of its attribute discovery command.
   1562            }
   1563          
   1564            return ( TRUE );
   1565          }
   1566          #endif // ZCL_DISCOVER
   1567          
   1568          #if ZCL_EZMODE
   1569          /*********************************************************************
   1570           * @fn      zclSampleLight_ProcessZDOMsgs
   1571           *
   1572           * @brief   Called when this node receives a ZDO/ZDP response.
   1573           *
   1574           * @param   none
   1575           *
   1576           * @return  status
   1577           */
   1578          static void zclSampleLight_ProcessZDOMsgs( zdoIncomingMsg_t *pMsg )
   1579          {
   1580            zclEZMode_ActionData_t data;
   1581            ZDO_MatchDescRsp_t *pMatchDescRsp;
   1582          
   1583            // Let EZ-Mode know of the Simple Descriptor Response
   1584            if ( pMsg->clusterID == Match_Desc_rsp )
   1585            {
   1586              pMatchDescRsp = ZDO_ParseEPListRsp( pMsg );
   1587              data.pMatchDescRsp = pMatchDescRsp;
   1588              zcl_EZModeAction( EZMODE_ACTION_MATCH_DESC_RSP, &data );
   1589              osal_mem_free( pMatchDescRsp );
   1590            }
   1591          }
   1592          
   1593          /*********************************************************************
   1594           * @fn      zclSampleLight_EZModeCB
   1595           *
   1596           * @brief   The Application is informed of events. This can be used to show on the UI what is
   1597          *           going on during EZ-Mode steering/finding/binding.
   1598           *
   1599           * @param   state - an
   1600           *
   1601           * @return  none
   1602           */
   1603          static void zclSampleLight_EZModeCB( zlcEZMode_State_t state, zclEZMode_CBData_t *pData )
   1604          {
   1605          #ifdef LCD_SUPPORTED
   1606            char *pStr;
   1607            uint8 err;
   1608          #endif
   1609          
   1610            // time to go into identify mode
   1611            if ( state == EZMODE_STATE_IDENTIFYING )
   1612            {
   1613          #ifdef LCD_SUPPORTED
   1614              HalLcdWriteString( "EZMode", HAL_LCD_LINE_2 );
   1615          #endif
   1616          
   1617              zclSampleLight_IdentifyTime = ( EZMODE_TIME / 1000 );  // convert to seconds
   1618              zclSampleLight_ProcessIdentifyTimeChange();
   1619            }
   1620          
   1621            // autoclosing, show what happened (success, cancelled, etc...)
   1622            if( state == EZMODE_STATE_AUTOCLOSE )
   1623            {
   1624          #ifdef LCD_SUPPORTED
   1625              pStr = NULL;
   1626              err = pData->sAutoClose.err;
   1627              if ( err == EZMODE_ERR_SUCCESS )
   1628              {
   1629                pStr = "EZMode: Success";
   1630              }
   1631              else if ( err == EZMODE_ERR_NOMATCH )
   1632              {
   1633                pStr = "EZMode: NoMatch"; // not a match made in heaven
   1634              }
   1635              if ( pStr )
   1636              {
   1637                if ( giLightScreenMode == LIGHT_MAINMODE )
   1638                {
   1639                  HalLcdWriteString ( pStr, HAL_LCD_LINE_2 );
   1640                }
   1641              }
   1642          #endif
   1643            }
   1644          
   1645            // finished, either show DstAddr/EP, or nothing (depending on success or not)
   1646            if( state == EZMODE_STATE_FINISH )
   1647            {
   1648              // turn off identify mode
   1649              zclSampleLight_IdentifyTime = 0;
   1650              zclSampleLight_ProcessIdentifyTimeChange();
   1651          
   1652          #ifdef LCD_SUPPORTED
   1653              // if successful, inform user which nwkaddr/ep we bound to
   1654              pStr = NULL;
   1655              err = pData->sFinish.err;
   1656              if( err == EZMODE_ERR_SUCCESS )
   1657              {
   1658                // already stated on autoclose
   1659              }
   1660              else if ( err == EZMODE_ERR_CANCELLED )
   1661              {
   1662                pStr = "EZMode: Cancel";
   1663              }
   1664              else if ( err == EZMODE_ERR_BAD_PARAMETER )
   1665              {
   1666                pStr = "EZMode: BadParm";
   1667              }
   1668              else if ( err == EZMODE_ERR_TIMEDOUT )
   1669              {
   1670                pStr = "EZMode: TimeOut";
   1671              }
   1672              if ( pStr )
   1673              {
   1674                if ( giLightScreenMode == LIGHT_MAINMODE )
   1675                {
   1676                  HalLcdWriteString ( pStr, HAL_LCD_LINE_2 );
   1677                }
   1678              }
   1679          #endif
   1680              // show main UI screen 3 seconds after binding
   1681              osal_start_timerEx( zclSampleLight_TaskID, SAMPLELIGHT_MAIN_SCREEN_EVT, 3000 );
   1682            }
   1683          }
   1684          #endif // ZCL_EZMODE
   1685          
   1686          /****************************************************************************
   1687          ****************************************************************************/
   1688          
   1689          

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2     24   zclSampleLight_BasicResetCB
        2      5   -> NLME_LeaveReq
        2      5   -> ZDApp_LeaveReset
        2      5   -> osal_memset
        2      5   -> zgWriteStartupOptions
      0     40   zclSampleLight_HandleKeys
        0     19   -> HalLedSet
        0     19   -> NLME_GetShortAddr
        0     20   -> NLME_SendNetworkStatus
        0     28   -> ZDP_EndDeviceBindReq
        0     19   -> ZDP_MgmtPermitJoinReq
        0     19   -> zclSampleLight_BasicResetCB
        0     19   -> zclSampleLight_LcdDisplayUpdate
      2      0   zclSampleLight_IdentifyCB
        2      0   -> zclSampleLight_ProcessIdentifyTimeChange
      0      0   zclSampleLight_IdentifyQueryRspCB
      0      9   zclSampleLight_Init
        0      9   -> HalLcdWriteString
        0      9   -> HalUARTWrite
        0      9   -> MT_UartInit
        0      9   -> MT_UartRegisterTaskID
        0      9   -> RegisterForKeys
        0      9   -> afRegister
        0      9   -> zclGeneral_RegisterCmdCallbacks
        0      9   -> zclHA_Init
        0      9   -> zcl_registerAttrList
        0      9   -> zcl_registerForMsg
      2     19   zclSampleLight_LcdDisplayUpdate
        2      0   -> HalLcdWriteString
        2      0   -> HalLedSet
        2      0   -> zclHA_LcdStatusLine1
      0     10   zclSampleLight_OnOffCB
        0     10   -> zclSampleLight_LcdDisplayUpdate
        0     10   -> zcl_getRawAFMsg
      2     16   zclSampleLight_ProcessIdentifyTimeChange
        2      0   -> HalLedBlink
        2      4   -> osal_start_timerEx
        2      0   -> osal_stop_timerEx
      0     12   zclSampleLight_event_loop
        0     12   -> osal_mem_free
        0     12   -> osal_msg_deallocate
        0     12   -> osal_msg_receive
        0     12   -> zclSampleLight_HandleKeys
        0     12   -> zclSampleLight_LcdDisplayUpdate
        0     12   -> zclSampleLight_ProcessIdentifyTimeChange


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      13  ?<Constant "UartInit OK\n">
       2  ?<Initializer for bindingInClusters>
      17  ?<Initializer for sSwHelp>
       6  ?<Initializer for sampleLight_TestEp>
      20  ?<Initializer for zclSampleLight_CmdCallbacks>
       1  ?<Initializer for zclSampleLight_NwkState>
       6  ??Subroutine4_0
       5  ?Subroutine0
       7  ?Subroutine1
      12  ?Subroutine2
       3  ?Subroutine3
       4  __Constant_3e8
       2  bindingInClusters
       1  gPermitDuration
       1  giLightScreenMode
       2  sClearLine
      15  sDeviceName
      14  sLightOff
      14  sLightOn
      13  sSwEZMode
      17  sSwHelp
      17  sSwLight
       6  sampleLight_TestEp
       1  zclSampleLightSeqNum
      57  zclSampleLight_BasicResetCB
      20  zclSampleLight_CmdCallbacks
      12  zclSampleLight_DstAddr
     282  zclSampleLight_HandleKeys
      26  zclSampleLight_IdentifyCB
       3  zclSampleLight_IdentifyQueryRspCB
     113  zclSampleLight_Init
     136  zclSampleLight_LcdDisplayUpdate
       1  zclSampleLight_NwkState
      68  zclSampleLight_OnOffCB
      63  zclSampleLight_ProcessIdentifyTimeChange
       1  zclSampleLight_TaskID
     198  zclSampleLight_event_loop
      54  -- Other

 
 979 bytes in segment BANKED_CODE
  54 bytes in segment BANK_RELAYS
  46 bytes in segment XDATA_I
  46 bytes in segment XDATA_ID
  92 bytes in segment XDATA_ROM_C
  16 bytes in segment XDATA_Z
 
 100 bytes of CODE     memory
  88 bytes of CONST    memory (+ 4 bytes shared)
 979 bytes of HUGECODE memory
  62 bytes of XDATA    memory

Errors: none
Warnings: none
